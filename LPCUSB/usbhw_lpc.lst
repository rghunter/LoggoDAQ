   1              		.cpu arm7tdmi-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 4
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"usbhw_lpc.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  18              	Wait4DevInt:
  19              	.LFB0:
  20              		.file 1 "../LPCUSB/usbhw_lpc.c"
   1:../LPCUSB/usbhw_lpc.c **** /*
   2:../LPCUSB/usbhw_lpc.c **** 	LPCUSB, an USB device driver for LPC microcontrollers	
   3:../LPCUSB/usbhw_lpc.c **** 	Copyright (C) 2006 Bertrik Sikken (bertrik@sikken.nl)
   4:../LPCUSB/usbhw_lpc.c **** 
   5:../LPCUSB/usbhw_lpc.c **** 	Redistribution and use in source and binary forms, with or without
   6:../LPCUSB/usbhw_lpc.c **** 	modification, are permitted provided that the following conditions are met:
   7:../LPCUSB/usbhw_lpc.c **** 
   8:../LPCUSB/usbhw_lpc.c **** 	1. Redistributions of source code must retain the above copyright
   9:../LPCUSB/usbhw_lpc.c **** 	   notice, this list of conditions and the following disclaimer.
  10:../LPCUSB/usbhw_lpc.c **** 	2. Redistributions in binary form must reproduce the above copyright
  11:../LPCUSB/usbhw_lpc.c **** 	   notice, this list of conditions and the following disclaimer in the
  12:../LPCUSB/usbhw_lpc.c **** 	   documentation and/or other materials provided with the distribution.
  13:../LPCUSB/usbhw_lpc.c **** 	3. The name of the author may not be used to endorse or promote products
  14:../LPCUSB/usbhw_lpc.c **** 	   derived from this software without specific prior written permission.
  15:../LPCUSB/usbhw_lpc.c **** 
  16:../LPCUSB/usbhw_lpc.c **** 	THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
  17:../LPCUSB/usbhw_lpc.c **** 	IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  18:../LPCUSB/usbhw_lpc.c **** 	OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  19:../LPCUSB/usbhw_lpc.c **** 	IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, 
  20:../LPCUSB/usbhw_lpc.c **** 	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  21:../LPCUSB/usbhw_lpc.c **** 	NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  22:../LPCUSB/usbhw_lpc.c **** 	DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  23:../LPCUSB/usbhw_lpc.c **** 	THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  24:../LPCUSB/usbhw_lpc.c **** 	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  25:../LPCUSB/usbhw_lpc.c **** 	THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  26:../LPCUSB/usbhw_lpc.c **** */
  27:../LPCUSB/usbhw_lpc.c **** 
  28:../LPCUSB/usbhw_lpc.c **** 
  29:../LPCUSB/usbhw_lpc.c **** /** @file
  30:../LPCUSB/usbhw_lpc.c **** 	USB hardware layer
  31:../LPCUSB/usbhw_lpc.c ****  */
  32:../LPCUSB/usbhw_lpc.c **** 
  33:../LPCUSB/usbhw_lpc.c **** #include "type.h"
  34:../LPCUSB/usbhw_lpc.c **** #include "usbdebug.h"
  35:../LPCUSB/usbhw_lpc.c **** #include "usbhw_lpc.h"
  36:../LPCUSB/usbhw_lpc.c **** #include "usbapi.h"
  37:../LPCUSB/usbhw_lpc.c **** 
  38:../LPCUSB/usbhw_lpc.c **** #include "rprintf.h"
  39:../LPCUSB/usbhw_lpc.c **** 
  40:../LPCUSB/usbhw_lpc.c **** 
  41:../LPCUSB/usbhw_lpc.c **** #ifdef DEBUG
  42:../LPCUSB/usbhw_lpc.c **** // comment out the following line if you don't want to use debug LEDs
  43:../LPCUSB/usbhw_lpc.c **** //#define DEBUG_LED
  44:../LPCUSB/usbhw_lpc.c **** #endif
  45:../LPCUSB/usbhw_lpc.c **** 
  46:../LPCUSB/usbhw_lpc.c **** #ifdef DEBUG_LED
  47:../LPCUSB/usbhw_lpc.c **** #define DEBUG_LED_ON(x)		IOCLR0 = (1 << x);
  48:../LPCUSB/usbhw_lpc.c **** #define DEBUG_LED_OFF(x)	IOSET0 = (1 << x);
  49:../LPCUSB/usbhw_lpc.c **** #define DEBUG_LED_INIT(x)	PINSEL0 &= ~(0x3 << (2*x)); IODIR0 |= (1 << x); DEBUG_LED_OFF(x);
  50:../LPCUSB/usbhw_lpc.c **** #else
  51:../LPCUSB/usbhw_lpc.c **** #define DEBUG_LED_INIT(x)	/**< LED initialisation macro */
  52:../LPCUSB/usbhw_lpc.c **** #define DEBUG_LED_ON(x)		/**< turn LED on */
  53:../LPCUSB/usbhw_lpc.c **** #define DEBUG_LED_OFF(x)	/**< turn LED off */
  54:../LPCUSB/usbhw_lpc.c **** #endif
  55:../LPCUSB/usbhw_lpc.c **** 
  56:../LPCUSB/usbhw_lpc.c **** /** Installed device interrupt handler */
  57:../LPCUSB/usbhw_lpc.c **** static TFnDevIntHandler *_pfnDevIntHandler = NULL;
  58:../LPCUSB/usbhw_lpc.c **** /** Installed endpoint interrupt handlers */
  59:../LPCUSB/usbhw_lpc.c **** static TFnEPIntHandler	*_apfnEPIntHandlers[16];
  60:../LPCUSB/usbhw_lpc.c **** /** Installed frame interrupt handlers */
  61:../LPCUSB/usbhw_lpc.c **** static TFnFrameHandler	*_pfnFrameHandler = NULL;
  62:../LPCUSB/usbhw_lpc.c **** 
  63:../LPCUSB/usbhw_lpc.c **** /** convert from endpoint address to endpoint index */
  64:../LPCUSB/usbhw_lpc.c **** #define EP2IDX(bEP)	((((bEP)&0xF)<<1)|(((bEP)&0x80)>>7))
  65:../LPCUSB/usbhw_lpc.c **** /** convert from endpoint index to endpoint address */
  66:../LPCUSB/usbhw_lpc.c **** #define IDX2EP(idx)	((((idx)<<7)&0x80)|(((idx)>>1)&0xF))
  67:../LPCUSB/usbhw_lpc.c **** 
  68:../LPCUSB/usbhw_lpc.c **** 
  69:../LPCUSB/usbhw_lpc.c **** 
  70:../LPCUSB/usbhw_lpc.c **** /**
  71:../LPCUSB/usbhw_lpc.c **** 	Local function to wait for a device interrupt (and clear it)
  72:../LPCUSB/usbhw_lpc.c **** 		
  73:../LPCUSB/usbhw_lpc.c **** 	@param [in]	dwIntr		Bitmask of interrupts to wait for	
  74:../LPCUSB/usbhw_lpc.c ****  */
  75:../LPCUSB/usbhw_lpc.c **** static void Wait4DevInt(U32 dwIntr)
  76:../LPCUSB/usbhw_lpc.c **** {
  21              		.loc 1 76 0
  22              		.cfi_startproc
  23              		@ Function supports interworking.
  24              		@ args = 0, pretend = 0, frame = 0
  25              		@ frame_needed = 0, uses_anonymous_args = 0
  26              		@ link register save eliminated.
  27              	.LVL0:
  77:../LPCUSB/usbhw_lpc.c **** 	// wait for specific interrupt
  78:../LPCUSB/usbhw_lpc.c **** 	while ((USBDevIntSt & dwIntr) != dwIntr);
  28              		.loc 1 78 0
  29 0000 18309FE5 		ldr	r3, .L4
  30              	.L2:
  31              		.loc 1 78 0 is_stmt 0 discriminator 1
  32 0004 002093E5 		ldr	r2, [r3, #0]
  33 0008 022000E0 		and	r2, r0, r2
  34 000c 000052E1 		cmp	r2, r0
  35 0010 FBFFFF1A 		bne	.L2
  79:../LPCUSB/usbhw_lpc.c **** 	// clear the interrupt bits
  80:../LPCUSB/usbhw_lpc.c **** 	USBDevIntClr = dwIntr;
  36              		.loc 1 80 0 is_stmt 1
  37 0014 04309FE5 		ldr	r3, .L4
  38 0018 080083E5 		str	r0, [r3, #8]
  81:../LPCUSB/usbhw_lpc.c **** }
  39              		.loc 1 81 0
  40 001c 1EFF2FE1 		bx	lr
  41              	.L5:
  42              		.align	2
  43              	.L4:
  44 0020 000009E0 		.word	-536281088
  45              		.cfi_endproc
  46              	.LFE0:
  48              		.align	2
  50              	USBHwCmd:
  51              	.LFB1:
  82:../LPCUSB/usbhw_lpc.c **** 
  83:../LPCUSB/usbhw_lpc.c **** 
  84:../LPCUSB/usbhw_lpc.c **** /**
  85:../LPCUSB/usbhw_lpc.c **** 	Local function to send a command to the USB protocol engine
  86:../LPCUSB/usbhw_lpc.c **** 		
  87:../LPCUSB/usbhw_lpc.c **** 	@param [in]	bCmd		Command to send
  88:../LPCUSB/usbhw_lpc.c ****  */
  89:../LPCUSB/usbhw_lpc.c **** static void USBHwCmd(U8 bCmd)
  90:../LPCUSB/usbhw_lpc.c **** {
  52              		.loc 1 90 0
  53              		.cfi_startproc
  54              		@ Function supports interworking.
  55              		@ args = 0, pretend = 0, frame = 0
  56              		@ frame_needed = 0, uses_anonymous_args = 0
  57              		@ link register save eliminated.
  58              	.LVL1:
  91:../LPCUSB/usbhw_lpc.c **** 	// clear CDFULL/CCEMTY
  92:../LPCUSB/usbhw_lpc.c **** 	USBDevIntClr = CDFULL | CCEMTY;
  59              		.loc 1 92 0
  60 0024 18309FE5 		ldr	r3, .L7
  93:../LPCUSB/usbhw_lpc.c **** 	// write command code
  94:../LPCUSB/usbhw_lpc.c **** 	USBCmdCode = 0x00000500 | (bCmd << 16);
  61              		.loc 1 94 0
  62 0028 0008A0E1 		mov	r0, r0, asl #16
  63              	.LVL2:
  92:../LPCUSB/usbhw_lpc.c **** 	USBDevIntClr = CDFULL | CCEMTY;
  64              		.loc 1 92 0
  65 002c 3020A0E3 		mov	r2, #48
  66              		.loc 1 94 0
  67 0030 050C80E3 		orr	r0, r0, #1280
  92:../LPCUSB/usbhw_lpc.c **** 	USBDevIntClr = CDFULL | CCEMTY;
  68              		.loc 1 92 0
  69 0034 082083E5 		str	r2, [r3, #8]
  70              		.loc 1 94 0
  71 0038 100083E5 		str	r0, [r3, #16]
  95:../LPCUSB/usbhw_lpc.c **** 	Wait4DevInt(CCEMTY);
  72              		.loc 1 95 0
  73 003c 1000A0E3 		mov	r0, #16
  96:../LPCUSB/usbhw_lpc.c **** }
  74              		.loc 1 96 0
  95:../LPCUSB/usbhw_lpc.c **** 	Wait4DevInt(CCEMTY);
  75              		.loc 1 95 0
  76 0040 EEFFFFEA 		b	Wait4DevInt
  77              	.L8:
  78              		.align	2
  79              	.L7:
  80 0044 000009E0 		.word	-536281088
  81              		.cfi_endproc
  82              	.LFE1:
  84              		.align	2
  86              	USBHwCmdWrite:
  87              	.LFB2:
  97:../LPCUSB/usbhw_lpc.c **** 
  98:../LPCUSB/usbhw_lpc.c **** 
  99:../LPCUSB/usbhw_lpc.c **** /**
 100:../LPCUSB/usbhw_lpc.c **** 	Local function to send a command + data to the USB protocol engine
 101:../LPCUSB/usbhw_lpc.c **** 		
 102:../LPCUSB/usbhw_lpc.c **** 	@param [in]	bCmd		Command to send
 103:../LPCUSB/usbhw_lpc.c **** 	@param [in]	bData		Data to send
 104:../LPCUSB/usbhw_lpc.c ****  */
 105:../LPCUSB/usbhw_lpc.c **** static void USBHwCmdWrite(U8 bCmd, U16 bData)
 106:../LPCUSB/usbhw_lpc.c **** {
  88              		.loc 1 106 0
  89              		.cfi_startproc
  90              		@ Function supports interworking.
  91              		@ args = 0, pretend = 0, frame = 0
  92              		@ frame_needed = 0, uses_anonymous_args = 0
  93              	.LVL3:
  94 0048 10402DE9 		stmfd	sp!, {r4, lr}
  95              	.LCFI0:
  96              		.cfi_def_cfa_offset 8
  97              		.cfi_offset 14, -4
  98              		.cfi_offset 4, -8
  99              		.loc 1 106 0
 100 004c 0140A0E1 		mov	r4, r1
 107:../LPCUSB/usbhw_lpc.c **** 	// write command code
 108:../LPCUSB/usbhw_lpc.c **** 	USBHwCmd(bCmd);
 101              		.loc 1 108 0
 102 0050 F3FFFFEB 		bl	USBHwCmd
 103              	.LVL4:
 109:../LPCUSB/usbhw_lpc.c **** 
 110:../LPCUSB/usbhw_lpc.c **** 	// write command data
 111:../LPCUSB/usbhw_lpc.c **** 	USBCmdCode = 0x00000100 | (bData << 16);
 104              		.loc 1 111 0
 105 0054 0448A0E1 		mov	r4, r4, asl #16
 106 0058 10309FE5 		ldr	r3, .L10
 107 005c 014C84E3 		orr	r4, r4, #256
 112:../LPCUSB/usbhw_lpc.c **** 	Wait4DevInt(CCEMTY);
 108              		.loc 1 112 0
 109 0060 1000A0E3 		mov	r0, #16
 111:../LPCUSB/usbhw_lpc.c **** 	USBCmdCode = 0x00000100 | (bData << 16);
 110              		.loc 1 111 0
 111 0064 104083E5 		str	r4, [r3, #16]
 113:../LPCUSB/usbhw_lpc.c **** }
 112              		.loc 1 113 0
 113 0068 1040BDE8 		ldmfd	sp!, {r4, lr}
 112:../LPCUSB/usbhw_lpc.c **** 	Wait4DevInt(CCEMTY);
 114              		.loc 1 112 0
 115 006c E3FFFFEA 		b	Wait4DevInt
 116              	.L11:
 117              		.align	2
 118              	.L10:
 119 0070 000009E0 		.word	-536281088
 120              		.cfi_endproc
 121              	.LFE2:
 123              		.align	2
 125              	USBHwCmdRead:
 126              	.LFB3:
 114:../LPCUSB/usbhw_lpc.c **** 
 115:../LPCUSB/usbhw_lpc.c **** 
 116:../LPCUSB/usbhw_lpc.c **** /**
 117:../LPCUSB/usbhw_lpc.c **** 	Local function to send a command to the USB protocol engine and read data
 118:../LPCUSB/usbhw_lpc.c **** 		
 119:../LPCUSB/usbhw_lpc.c **** 	@param [in]	bCmd		Command to send
 120:../LPCUSB/usbhw_lpc.c **** 
 121:../LPCUSB/usbhw_lpc.c **** 	@return the data
 122:../LPCUSB/usbhw_lpc.c ****  */
 123:../LPCUSB/usbhw_lpc.c **** static U8 USBHwCmdRead(U8 bCmd)
 124:../LPCUSB/usbhw_lpc.c **** {
 127              		.loc 1 124 0
 128              		.cfi_startproc
 129              		@ Function supports interworking.
 130              		@ args = 0, pretend = 0, frame = 0
 131              		@ frame_needed = 0, uses_anonymous_args = 0
 132              	.LVL5:
 133 0074 10402DE9 		stmfd	sp!, {r4, lr}
 134              	.LCFI1:
 135              		.cfi_def_cfa_offset 8
 136              		.cfi_offset 14, -4
 137              		.cfi_offset 4, -8
 138              		.loc 1 124 0
 139 0078 0040A0E1 		mov	r4, r0
 125:../LPCUSB/usbhw_lpc.c **** 	// write command code
 126:../LPCUSB/usbhw_lpc.c **** 	USBHwCmd(bCmd);
 127:../LPCUSB/usbhw_lpc.c **** 	
 128:../LPCUSB/usbhw_lpc.c **** 	// get data
 129:../LPCUSB/usbhw_lpc.c **** 	USBCmdCode = 0x00000200 | (bCmd << 16);
 140              		.loc 1 129 0
 141 007c 0448A0E1 		mov	r4, r4, asl #16
 126:../LPCUSB/usbhw_lpc.c **** 	USBHwCmd(bCmd);
 142              		.loc 1 126 0
 143 0080 E7FFFFEB 		bl	USBHwCmd
 144              	.LVL6:
 145              		.loc 1 129 0
 146 0084 023C84E3 		orr	r3, r4, #512
 147 0088 18409FE5 		ldr	r4, .L13
 130:../LPCUSB/usbhw_lpc.c **** 	Wait4DevInt(CDFULL);
 148              		.loc 1 130 0
 149 008c 2000A0E3 		mov	r0, #32
 129:../LPCUSB/usbhw_lpc.c **** 	USBCmdCode = 0x00000200 | (bCmd << 16);
 150              		.loc 1 129 0
 151 0090 103084E5 		str	r3, [r4, #16]
 152              		.loc 1 130 0
 153 0094 D9FFFFEB 		bl	Wait4DevInt
 131:../LPCUSB/usbhw_lpc.c **** 	return USBCmdData;
 154              		.loc 1 131 0
 155 0098 140094E5 		ldr	r0, [r4, #20]
 156 009c FF0000E2 		and	r0, r0, #255
 132:../LPCUSB/usbhw_lpc.c **** }
 157              		.loc 1 132 0
 158 00a0 1040BDE8 		ldmfd	sp!, {r4, lr}
 159 00a4 1EFF2FE1 		bx	lr
 160              	.L14:
 161              		.align	2
 162              	.L13:
 163 00a8 000009E0 		.word	-536281088
 164              		.cfi_endproc
 165              	.LFE3:
 167              		.align	2
 168              		.global	USBHwEPConfig
 170              	USBHwEPConfig:
 171              	.LFB6:
 133:../LPCUSB/usbhw_lpc.c **** 
 134:../LPCUSB/usbhw_lpc.c **** 
 135:../LPCUSB/usbhw_lpc.c **** /**
 136:../LPCUSB/usbhw_lpc.c **** 	'Realizes' an endpoint, meaning that buffer space is reserved for
 137:../LPCUSB/usbhw_lpc.c **** 	it. An endpoint needs to be realised before it can be used.
 138:../LPCUSB/usbhw_lpc.c **** 		
 139:../LPCUSB/usbhw_lpc.c **** 	From experiments, it appears that a USB reset causes USBReEP to
 140:../LPCUSB/usbhw_lpc.c **** 	re-initialise to 3 (= just the control endpoints).
 141:../LPCUSB/usbhw_lpc.c **** 	However, a USB bus reset does not disturb the USBMaxPSize settings.
 142:../LPCUSB/usbhw_lpc.c **** 		
 143:../LPCUSB/usbhw_lpc.c **** 	@param [in]	idx			Endpoint index
 144:../LPCUSB/usbhw_lpc.c **** 	@param [in] wMaxPSize	Maximum packet size for this endpoint
 145:../LPCUSB/usbhw_lpc.c ****  */
 146:../LPCUSB/usbhw_lpc.c **** static void USBHwEPRealize(int idx, U16 wMaxPSize)
 147:../LPCUSB/usbhw_lpc.c **** {
 148:../LPCUSB/usbhw_lpc.c **** 	USBReEP |= (1 << idx);
 149:../LPCUSB/usbhw_lpc.c **** 	USBEpInd = idx;
 150:../LPCUSB/usbhw_lpc.c **** 	USBMaxPSize = wMaxPSize;
 151:../LPCUSB/usbhw_lpc.c **** 	Wait4DevInt(EP_RLZED);
 152:../LPCUSB/usbhw_lpc.c **** }
 153:../LPCUSB/usbhw_lpc.c **** 
 154:../LPCUSB/usbhw_lpc.c **** 
 155:../LPCUSB/usbhw_lpc.c **** /**
 156:../LPCUSB/usbhw_lpc.c **** 	Enables or disables an endpoint
 157:../LPCUSB/usbhw_lpc.c **** 		
 158:../LPCUSB/usbhw_lpc.c **** 	@param [in]	idx		Endpoint index
 159:../LPCUSB/usbhw_lpc.c **** 	@param [in]	fEnable	TRUE to enable, FALSE to disable
 160:../LPCUSB/usbhw_lpc.c ****  */
 161:../LPCUSB/usbhw_lpc.c **** static void USBHwEPEnable(int idx, BOOL fEnable)
 162:../LPCUSB/usbhw_lpc.c **** {
 163:../LPCUSB/usbhw_lpc.c **** 	USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fEnable ? 0 : EP_DA);
 164:../LPCUSB/usbhw_lpc.c **** }
 165:../LPCUSB/usbhw_lpc.c **** 
 166:../LPCUSB/usbhw_lpc.c **** 
 167:../LPCUSB/usbhw_lpc.c **** /**
 168:../LPCUSB/usbhw_lpc.c **** 	Configures an endpoint and enables it
 169:../LPCUSB/usbhw_lpc.c **** 		
 170:../LPCUSB/usbhw_lpc.c **** 	@param [in]	bEP				Endpoint number
 171:../LPCUSB/usbhw_lpc.c **** 	@param [in]	wMaxPacketSize	Maximum packet size for this EP
 172:../LPCUSB/usbhw_lpc.c ****  */
 173:../LPCUSB/usbhw_lpc.c **** void USBHwEPConfig(U8 bEP, U16 wMaxPacketSize)
 174:../LPCUSB/usbhw_lpc.c **** {
 172              		.loc 1 174 0
 173              		.cfi_startproc
 174              		@ Function supports interworking.
 175              		@ args = 0, pretend = 0, frame = 0
 176              		@ frame_needed = 0, uses_anonymous_args = 0
 177              	.LVL7:
 178              	.LBB6:
 179              	.LBB7:
 148:../LPCUSB/usbhw_lpc.c **** 	USBReEP |= (1 << idx);
 180              		.loc 1 148 0
 181 00ac 3C309FE5 		ldr	r3, .L16
 182              	.LBE7:
 183              	.LBE6:
 184              		.loc 1 174 0
 185 00b0 10402DE9 		stmfd	sp!, {r4, lr}
 186              	.LCFI2:
 187              		.cfi_def_cfa_offset 8
 188              		.cfi_offset 14, -4
 189              		.cfi_offset 4, -8
 190              	.LBB10:
 191              	.LBB8:
 148:../LPCUSB/usbhw_lpc.c **** 	USBReEP |= (1 << idx);
 192              		.loc 1 148 0
 193 00b4 442093E5 		ldr	r2, [r3, #68]
 194              	.LBE8:
 195              	.LBE10:
 175:../LPCUSB/usbhw_lpc.c **** 	int idx;
 176:../LPCUSB/usbhw_lpc.c **** 	
 177:../LPCUSB/usbhw_lpc.c **** 	idx = EP2IDX(bEP);
 196              		.loc 1 177 0
 197 00b8 0F4000E2 		and	r4, r0, #15
 198 00bc A003A0E1 		mov	r0, r0, lsr #7
 199              	.LVL8:
 200 00c0 844080E1 		orr	r4, r0, r4, asl #1
 201              	.LVL9:
 202              	.LBB11:
 203              	.LBB9:
 148:../LPCUSB/usbhw_lpc.c **** 	USBReEP |= (1 << idx);
 204              		.loc 1 148 0
 205 00c4 0100A0E3 		mov	r0, #1
 206 00c8 102482E1 		orr	r2, r2, r0, asl r4
 151:../LPCUSB/usbhw_lpc.c **** 	Wait4DevInt(EP_RLZED);
 207              		.loc 1 151 0
 208 00cc 010CA0E3 		mov	r0, #256
 148:../LPCUSB/usbhw_lpc.c **** 	USBReEP |= (1 << idx);
 209              		.loc 1 148 0
 210 00d0 442083E5 		str	r2, [r3, #68]
 149:../LPCUSB/usbhw_lpc.c **** 	USBEpInd = idx;
 211              		.loc 1 149 0
 212 00d4 484083E5 		str	r4, [r3, #72]
 150:../LPCUSB/usbhw_lpc.c **** 	USBMaxPSize = wMaxPSize;
 213              		.loc 1 150 0
 214 00d8 4C1083E5 		str	r1, [r3, #76]
 151:../LPCUSB/usbhw_lpc.c **** 	Wait4DevInt(EP_RLZED);
 215              		.loc 1 151 0
 216 00dc C7FFFFEB 		bl	Wait4DevInt
 217              	.LVL10:
 218              	.LBE9:
 219              	.LBE11:
 220              	.LBB12:
 221              	.LBB13:
 163:../LPCUSB/usbhw_lpc.c **** 	USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fEnable ? 0 : EP_DA);
 222              		.loc 1 163 0
 223 00e0 400084E3 		orr	r0, r4, #64
 224 00e4 0010A0E3 		mov	r1, #0
 225              	.LBE13:
 226              	.LBE12:
 178:../LPCUSB/usbhw_lpc.c **** 	
 179:../LPCUSB/usbhw_lpc.c **** 	// realise EP
 180:../LPCUSB/usbhw_lpc.c **** 	USBHwEPRealize(idx, wMaxPacketSize);
 181:../LPCUSB/usbhw_lpc.c **** 
 182:../LPCUSB/usbhw_lpc.c **** 	// enable EP
 183:../LPCUSB/usbhw_lpc.c **** 	USBHwEPEnable(idx, TRUE);
 184:../LPCUSB/usbhw_lpc.c **** }
 227              		.loc 1 184 0
 228 00e8 1040BDE8 		ldmfd	sp!, {r4, lr}
 229              	.LBB15:
 230              	.LBB14:
 163:../LPCUSB/usbhw_lpc.c **** 	USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fEnable ? 0 : EP_DA);
 231              		.loc 1 163 0
 232 00ec D5FFFFEA 		b	USBHwCmdWrite
 233              	.L17:
 234              		.align	2
 235              	.L16:
 236 00f0 000009E0 		.word	-536281088
 237              	.LBE14:
 238              	.LBE15:
 239              		.cfi_endproc
 240              	.LFE6:
 242              		.align	2
 243              		.global	USBHwRegisterEPIntHandler
 245              	USBHwRegisterEPIntHandler:
 246              	.LFB7:
 185:../LPCUSB/usbhw_lpc.c **** 
 186:../LPCUSB/usbhw_lpc.c **** 
 187:../LPCUSB/usbhw_lpc.c **** /**
 188:../LPCUSB/usbhw_lpc.c **** 	Registers an endpoint event callback
 189:../LPCUSB/usbhw_lpc.c **** 		
 190:../LPCUSB/usbhw_lpc.c **** 	@param [in]	bEP				Endpoint number
 191:../LPCUSB/usbhw_lpc.c **** 	@param [in]	pfnHandler		Callback function
 192:../LPCUSB/usbhw_lpc.c ****  */
 193:../LPCUSB/usbhw_lpc.c **** void USBHwRegisterEPIntHandler(U8 bEP, TFnEPIntHandler *pfnHandler)
 194:../LPCUSB/usbhw_lpc.c **** {
 247              		.loc 1 194 0
 248              		.cfi_startproc
 249              		@ Function supports interworking.
 250              		@ args = 0, pretend = 0, frame = 0
 251              		@ frame_needed = 0, uses_anonymous_args = 0
 252              		@ link register save eliminated.
 253              	.LVL11:
 195:../LPCUSB/usbhw_lpc.c **** 	int idx;
 196:../LPCUSB/usbhw_lpc.c **** 	
 197:../LPCUSB/usbhw_lpc.c **** 	idx = EP2IDX(bEP);
 198:../LPCUSB/usbhw_lpc.c **** 
 199:../LPCUSB/usbhw_lpc.c **** 	ASSERT(idx<32);
 200:../LPCUSB/usbhw_lpc.c **** 
 201:../LPCUSB/usbhw_lpc.c **** 	/* add handler to list of EP handlers */
 202:../LPCUSB/usbhw_lpc.c **** 	_apfnEPIntHandlers[idx / 2] = pfnHandler;
 254              		.loc 1 202 0
 255 00f4 30209FE5 		ldr	r2, .L19
 197:../LPCUSB/usbhw_lpc.c **** 	idx = EP2IDX(bEP);
 256              		.loc 1 197 0
 257 00f8 0F3000E2 		and	r3, r0, #15
 258 00fc A003A0E1 		mov	r0, r0, lsr #7
 259              	.LVL12:
 260              		.loc 1 202 0
 261 0100 031182E7 		str	r1, [r2, r3, asl #2]
 262 0104 830080E1 		orr	r0, r0, r3, asl #1
 263              	.LVL13:
 203:../LPCUSB/usbhw_lpc.c **** 	
 204:../LPCUSB/usbhw_lpc.c **** 	/* enable EP interrupt */
 205:../LPCUSB/usbhw_lpc.c **** 	USBEpIntEn |= (1 << idx);
 264              		.loc 1 205 0
 265 0108 20309FE5 		ldr	r3, .L19+4
 266 010c 342093E5 		ldr	r2, [r3, #52]
 267 0110 0110A0E3 		mov	r1, #1
 268              	.LVL14:
 269 0114 110082E1 		orr	r0, r2, r1, asl r0
 270              	.LVL15:
 271 0118 340083E5 		str	r0, [r3, #52]
 206:../LPCUSB/usbhw_lpc.c **** 	USBDevIntEn |= EP_SLOW;
 272              		.loc 1 206 0
 273 011c 042093E5 		ldr	r2, [r3, #4]
 274 0120 042082E3 		orr	r2, r2, #4
 275 0124 042083E5 		str	r2, [r3, #4]
 207:../LPCUSB/usbhw_lpc.c **** 	
 208:../LPCUSB/usbhw_lpc.c **** 	DBG("Registered handler for EP 0x%x\n", bEP);
 209:../LPCUSB/usbhw_lpc.c **** }
 276              		.loc 1 209 0
 277 0128 1EFF2FE1 		bx	lr
 278              	.L20:
 279              		.align	2
 280              	.L19:
 281 012c 00000000 		.word	.LANCHOR0
 282 0130 000009E0 		.word	-536281088
 283              		.cfi_endproc
 284              	.LFE7:
 286              		.align	2
 287              		.global	USBHwRegisterDevIntHandler
 289              	USBHwRegisterDevIntHandler:
 290              	.LFB8:
 210:../LPCUSB/usbhw_lpc.c **** 
 211:../LPCUSB/usbhw_lpc.c **** 
 212:../LPCUSB/usbhw_lpc.c **** /**
 213:../LPCUSB/usbhw_lpc.c **** 	Registers an device status callback
 214:../LPCUSB/usbhw_lpc.c **** 		
 215:../LPCUSB/usbhw_lpc.c **** 	@param [in]	pfnHandler	Callback function
 216:../LPCUSB/usbhw_lpc.c ****  */
 217:../LPCUSB/usbhw_lpc.c **** void USBHwRegisterDevIntHandler(TFnDevIntHandler *pfnHandler)
 218:../LPCUSB/usbhw_lpc.c **** {
 291              		.loc 1 218 0
 292              		.cfi_startproc
 293              		@ Function supports interworking.
 294              		@ args = 0, pretend = 0, frame = 0
 295              		@ frame_needed = 0, uses_anonymous_args = 0
 296              		@ link register save eliminated.
 297              	.LVL16:
 219:../LPCUSB/usbhw_lpc.c **** 	_pfnDevIntHandler = pfnHandler;
 298              		.loc 1 219 0
 299 0134 14309FE5 		ldr	r3, .L22
 300 0138 400083E5 		str	r0, [r3, #64]
 220:../LPCUSB/usbhw_lpc.c **** 	
 221:../LPCUSB/usbhw_lpc.c **** 	// enable device interrupt
 222:../LPCUSB/usbhw_lpc.c **** 	USBDevIntEn |= DEV_STAT;
 301              		.loc 1 222 0
 302 013c 10309FE5 		ldr	r3, .L22+4
 303 0140 042093E5 		ldr	r2, [r3, #4]
 304 0144 082082E3 		orr	r2, r2, #8
 305 0148 042083E5 		str	r2, [r3, #4]
 223:../LPCUSB/usbhw_lpc.c **** 
 224:../LPCUSB/usbhw_lpc.c **** 	DBG("Registered handler for device status\n");
 225:../LPCUSB/usbhw_lpc.c **** }
 306              		.loc 1 225 0
 307 014c 1EFF2FE1 		bx	lr
 308              	.L23:
 309              		.align	2
 310              	.L22:
 311 0150 00000000 		.word	.LANCHOR0
 312 0154 000009E0 		.word	-536281088
 313              		.cfi_endproc
 314              	.LFE8:
 316              		.align	2
 317              		.global	USBHwRegisterFrameHandler
 319              	USBHwRegisterFrameHandler:
 320              	.LFB9:
 226:../LPCUSB/usbhw_lpc.c **** 
 227:../LPCUSB/usbhw_lpc.c **** 
 228:../LPCUSB/usbhw_lpc.c **** /**
 229:../LPCUSB/usbhw_lpc.c **** 	Registers the frame callback
 230:../LPCUSB/usbhw_lpc.c **** 		
 231:../LPCUSB/usbhw_lpc.c **** 	@param [in]	pfnHandler	Callback function
 232:../LPCUSB/usbhw_lpc.c ****  */
 233:../LPCUSB/usbhw_lpc.c **** void USBHwRegisterFrameHandler(TFnFrameHandler *pfnHandler)
 234:../LPCUSB/usbhw_lpc.c **** {
 321              		.loc 1 234 0
 322              		.cfi_startproc
 323              		@ Function supports interworking.
 324              		@ args = 0, pretend = 0, frame = 0
 325              		@ frame_needed = 0, uses_anonymous_args = 0
 326              		@ link register save eliminated.
 327              	.LVL17:
 235:../LPCUSB/usbhw_lpc.c **** 	_pfnFrameHandler = pfnHandler;
 328              		.loc 1 235 0
 329 0158 14309FE5 		ldr	r3, .L25
 330 015c 440083E5 		str	r0, [r3, #68]
 236:../LPCUSB/usbhw_lpc.c **** 	
 237:../LPCUSB/usbhw_lpc.c **** 	// enable device interrupt
 238:../LPCUSB/usbhw_lpc.c **** 	USBDevIntEn |= FRAME;
 331              		.loc 1 238 0
 332 0160 10309FE5 		ldr	r3, .L25+4
 333 0164 042093E5 		ldr	r2, [r3, #4]
 334 0168 012082E3 		orr	r2, r2, #1
 335 016c 042083E5 		str	r2, [r3, #4]
 239:../LPCUSB/usbhw_lpc.c **** 
 240:../LPCUSB/usbhw_lpc.c **** 	DBG("Registered handler for frame\n");
 241:../LPCUSB/usbhw_lpc.c **** }
 336              		.loc 1 241 0
 337 0170 1EFF2FE1 		bx	lr
 338              	.L26:
 339              		.align	2
 340              	.L25:
 341 0174 00000000 		.word	.LANCHOR0
 342 0178 000009E0 		.word	-536281088
 343              		.cfi_endproc
 344              	.LFE9:
 346              		.align	2
 347              		.global	USBHwSetAddress
 349              	USBHwSetAddress:
 350              	.LFB10:
 242:../LPCUSB/usbhw_lpc.c **** 
 243:../LPCUSB/usbhw_lpc.c **** 
 244:../LPCUSB/usbhw_lpc.c **** /**
 245:../LPCUSB/usbhw_lpc.c **** 	Sets the USB address.
 246:../LPCUSB/usbhw_lpc.c **** 		
 247:../LPCUSB/usbhw_lpc.c **** 	@param [in]	bAddr		Device address to set
 248:../LPCUSB/usbhw_lpc.c ****  */
 249:../LPCUSB/usbhw_lpc.c **** void USBHwSetAddress(U8 bAddr)
 250:../LPCUSB/usbhw_lpc.c **** {
 351              		.loc 1 250 0
 352              		.cfi_startproc
 353              		@ Function supports interworking.
 354              		@ args = 0, pretend = 0, frame = 0
 355              		@ frame_needed = 0, uses_anonymous_args = 0
 356              		@ link register save eliminated.
 357              	.LVL18:
 251:../LPCUSB/usbhw_lpc.c **** 	USBHwCmdWrite(CMD_DEV_SET_ADDRESS, DEV_EN | bAddr);
 358              		.loc 1 251 0
 359 017c 801080E3 		orr	r1, r0, #128
 360 0180 D000A0E3 		mov	r0, #208
 361              	.LVL19:
 252:../LPCUSB/usbhw_lpc.c **** }
 362              		.loc 1 252 0
 251:../LPCUSB/usbhw_lpc.c **** 	USBHwCmdWrite(CMD_DEV_SET_ADDRESS, DEV_EN | bAddr);
 363              		.loc 1 251 0
 364 0184 AFFFFFEA 		b	USBHwCmdWrite
 365              		.cfi_endproc
 366              	.LFE10:
 368              		.align	2
 369              		.global	USBHwConnect
 371              	USBHwConnect:
 372              	.LFB11:
 253:../LPCUSB/usbhw_lpc.c **** 
 254:../LPCUSB/usbhw_lpc.c **** 
 255:../LPCUSB/usbhw_lpc.c **** /**
 256:../LPCUSB/usbhw_lpc.c **** 	Connects or disconnects from the USB bus
 257:../LPCUSB/usbhw_lpc.c **** 		
 258:../LPCUSB/usbhw_lpc.c **** 	@param [in]	fConnect	If TRUE, connect, otherwise disconnect
 259:../LPCUSB/usbhw_lpc.c ****  */
 260:../LPCUSB/usbhw_lpc.c **** void USBHwConnect(BOOL fConnect)
 261:../LPCUSB/usbhw_lpc.c **** {
 373              		.loc 1 261 0
 374              		.cfi_startproc
 375              		@ Function supports interworking.
 376              		@ args = 0, pretend = 0, frame = 0
 377              		@ frame_needed = 0, uses_anonymous_args = 0
 378              		@ link register save eliminated.
 379              	.LVL20:
 262:../LPCUSB/usbhw_lpc.c **** 	USBHwCmdWrite(CMD_DEV_STATUS, fConnect ? CON : 0);
 380              		.loc 1 262 0
 381 0188 001090E2 		adds	r1, r0, #0
 382 018c 0110A013 		movne	r1, #1
 383 0190 FE00A0E3 		mov	r0, #254
 384              	.LVL21:
 263:../LPCUSB/usbhw_lpc.c **** 
 264:../LPCUSB/usbhw_lpc.c **** }
 385              		.loc 1 264 0
 262:../LPCUSB/usbhw_lpc.c **** 	USBHwCmdWrite(CMD_DEV_STATUS, fConnect ? CON : 0);
 386              		.loc 1 262 0
 387 0194 ABFFFFEA 		b	USBHwCmdWrite
 388              		.cfi_endproc
 389              	.LFE11:
 391              		.align	2
 392              		.global	USBHwNakIntEnable
 394              	USBHwNakIntEnable:
 395              	.LFB12:
 265:../LPCUSB/usbhw_lpc.c **** 
 266:../LPCUSB/usbhw_lpc.c **** 
 267:../LPCUSB/usbhw_lpc.c **** /**
 268:../LPCUSB/usbhw_lpc.c **** 	Enables interrupt on NAK condition
 269:../LPCUSB/usbhw_lpc.c **** 		
 270:../LPCUSB/usbhw_lpc.c **** 	For IN endpoints a NAK is generated when the host wants to read data
 271:../LPCUSB/usbhw_lpc.c **** 	from the device, but none is available in the endpoint buffer.
 272:../LPCUSB/usbhw_lpc.c **** 	For OUT endpoints a NAK is generated when the host wants to write data
 273:../LPCUSB/usbhw_lpc.c **** 	to the device, but the endpoint buffer is still full.
 274:../LPCUSB/usbhw_lpc.c **** 	
 275:../LPCUSB/usbhw_lpc.c **** 	The endpoint interrupt handlers can distinguish regular (ACK) interrupts
 276:../LPCUSB/usbhw_lpc.c **** 	from NAK interrupt by checking the bits in their bEPStatus argument.
 277:../LPCUSB/usbhw_lpc.c **** 	
 278:../LPCUSB/usbhw_lpc.c **** 	@param [in]	bIntBits	Bitmap indicating which NAK interrupts to enable
 279:../LPCUSB/usbhw_lpc.c ****  */
 280:../LPCUSB/usbhw_lpc.c **** void USBHwNakIntEnable(U8 bIntBits)
 281:../LPCUSB/usbhw_lpc.c **** {
 396              		.loc 1 281 0
 397              		.cfi_startproc
 398              		@ Function supports interworking.
 399              		@ args = 0, pretend = 0, frame = 0
 400              		@ frame_needed = 0, uses_anonymous_args = 0
 401              		@ link register save eliminated.
 402              	.LVL22:
 403              		.loc 1 281 0
 404 0198 0010A0E1 		mov	r1, r0
 282:../LPCUSB/usbhw_lpc.c **** 	USBHwCmdWrite(CMD_DEV_SET_MODE, bIntBits);
 405              		.loc 1 282 0
 406 019c F300A0E3 		mov	r0, #243
 407              	.LVL23:
 283:../LPCUSB/usbhw_lpc.c **** }
 408              		.loc 1 283 0
 282:../LPCUSB/usbhw_lpc.c **** 	USBHwCmdWrite(CMD_DEV_SET_MODE, bIntBits);
 409              		.loc 1 282 0
 410 01a0 A8FFFFEA 		b	USBHwCmdWrite
 411              		.cfi_endproc
 412              	.LFE12:
 414              		.align	2
 415              		.global	USBHwEPGetStatus
 417              	USBHwEPGetStatus:
 418              	.LFB13:
 284:../LPCUSB/usbhw_lpc.c **** 
 285:../LPCUSB/usbhw_lpc.c **** 
 286:../LPCUSB/usbhw_lpc.c **** /**
 287:../LPCUSB/usbhw_lpc.c **** 	Gets the status from a specific endpoint.
 288:../LPCUSB/usbhw_lpc.c **** 		
 289:../LPCUSB/usbhw_lpc.c **** 	@param [in]	bEP		Endpoint number
 290:../LPCUSB/usbhw_lpc.c **** 	@return Endpoint status byte (containing EP_STATUS_xxx bits)
 291:../LPCUSB/usbhw_lpc.c ****  */
 292:../LPCUSB/usbhw_lpc.c **** U8	USBHwEPGetStatus(U8 bEP)
 293:../LPCUSB/usbhw_lpc.c **** {
 419              		.loc 1 293 0
 420              		.cfi_startproc
 421              		@ Function supports interworking.
 422              		@ args = 0, pretend = 0, frame = 0
 423              		@ frame_needed = 0, uses_anonymous_args = 0
 424              		@ link register save eliminated.
 425              	.LVL24:
 294:../LPCUSB/usbhw_lpc.c **** 	int idx = EP2IDX(bEP);
 426              		.loc 1 294 0
 427 01a4 0F3000E2 		and	r3, r0, #15
 428 01a8 A003A0E1 		mov	r0, r0, lsr #7
 429              	.LVL25:
 295:../LPCUSB/usbhw_lpc.c **** 
 296:../LPCUSB/usbhw_lpc.c **** 	return USBHwCmdRead(CMD_EP_SELECT | idx);
 430              		.loc 1 296 0
 431 01ac 830080E1 		orr	r0, r0, r3, asl #1
 297:../LPCUSB/usbhw_lpc.c **** }
 432              		.loc 1 297 0
 296:../LPCUSB/usbhw_lpc.c **** 	return USBHwCmdRead(CMD_EP_SELECT | idx);
 433              		.loc 1 296 0
 434 01b0 AFFFFFEA 		b	USBHwCmdRead
 435              		.cfi_endproc
 436              	.LFE13:
 438              		.align	2
 439              		.global	USBHwEPStall
 441              	USBHwEPStall:
 442              	.LFB14:
 298:../LPCUSB/usbhw_lpc.c **** 
 299:../LPCUSB/usbhw_lpc.c **** 
 300:../LPCUSB/usbhw_lpc.c **** /**
 301:../LPCUSB/usbhw_lpc.c **** 	Sets the stalled property of an endpoint
 302:../LPCUSB/usbhw_lpc.c **** 		
 303:../LPCUSB/usbhw_lpc.c **** 	@param [in]	bEP		Endpoint number
 304:../LPCUSB/usbhw_lpc.c **** 	@param [in]	fStall	TRUE to stall, FALSE to unstall
 305:../LPCUSB/usbhw_lpc.c ****  */
 306:../LPCUSB/usbhw_lpc.c **** void USBHwEPStall(U8 bEP, BOOL fStall)
 307:../LPCUSB/usbhw_lpc.c **** {
 443              		.loc 1 307 0
 444              		.cfi_startproc
 445              		@ Function supports interworking.
 446              		@ args = 0, pretend = 0, frame = 0
 447              		@ frame_needed = 0, uses_anonymous_args = 0
 448              		@ link register save eliminated.
 449              	.LVL26:
 308:../LPCUSB/usbhw_lpc.c **** 	int idx = EP2IDX(bEP);
 450              		.loc 1 308 0
 451 01b4 0F3000E2 		and	r3, r0, #15
 452 01b8 A003A0E1 		mov	r0, r0, lsr #7
 453              	.LVL27:
 454 01bc 830080E1 		orr	r0, r0, r3, asl #1
 309:../LPCUSB/usbhw_lpc.c **** 
 310:../LPCUSB/usbhw_lpc.c **** 	USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fStall ? EP_ST : 0);
 455              		.loc 1 310 0
 456 01c0 001091E2 		adds	r1, r1, #0
 457 01c4 400080E3 		orr	r0, r0, #64
 458 01c8 0110A013 		movne	r1, #1
 459              	.LVL28:
 311:../LPCUSB/usbhw_lpc.c **** }
 460              		.loc 1 311 0
 310:../LPCUSB/usbhw_lpc.c **** 	USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fStall ? EP_ST : 0);
 461              		.loc 1 310 0
 462 01cc 9DFFFFEA 		b	USBHwCmdWrite
 463              		.cfi_endproc
 464              	.LFE14:
 466              		.align	2
 467              		.global	USBHwEPWrite
 469              	USBHwEPWrite:
 470              	.LFB15:
 312:../LPCUSB/usbhw_lpc.c **** 
 313:../LPCUSB/usbhw_lpc.c **** 
 314:../LPCUSB/usbhw_lpc.c **** /**
 315:../LPCUSB/usbhw_lpc.c **** 	Writes data to an endpoint buffer
 316:../LPCUSB/usbhw_lpc.c **** 		
 317:../LPCUSB/usbhw_lpc.c **** 	@param [in]	bEP		Endpoint number
 318:../LPCUSB/usbhw_lpc.c **** 	@param [in]	pbBuf	Endpoint data
 319:../LPCUSB/usbhw_lpc.c **** 	@param [in]	iLen	Number of bytes to write
 320:../LPCUSB/usbhw_lpc.c **** 			
 321:../LPCUSB/usbhw_lpc.c **** 	@return TRUE if the data was successfully written or <0 in case of error.
 322:../LPCUSB/usbhw_lpc.c **** */
 323:../LPCUSB/usbhw_lpc.c **** int USBHwEPWrite(U8 bEP, U8 *pbBuf, int iLen)
 324:../LPCUSB/usbhw_lpc.c **** {
 471              		.loc 1 324 0
 472              		.cfi_startproc
 473              		@ Function supports interworking.
 474              		@ args = 0, pretend = 0, frame = 0
 475              		@ frame_needed = 0, uses_anonymous_args = 0
 476              	.LVL29:
 325:../LPCUSB/usbhw_lpc.c **** 	int idx;
 326:../LPCUSB/usbhw_lpc.c **** 	
 327:../LPCUSB/usbhw_lpc.c **** 	idx = EP2IDX(bEP);
 477              		.loc 1 327 0
 478 01d0 0F3000E2 		and	r3, r0, #15
 479 01d4 A003A0E1 		mov	r0, r0, lsr #7
 480              	.LVL30:
 481 01d8 830080E1 		orr	r0, r0, r3, asl #1
 482              	.LVL31:
 328:../LPCUSB/usbhw_lpc.c **** 	
 329:../LPCUSB/usbhw_lpc.c **** 	// set write enable for specific endpoint
 330:../LPCUSB/usbhw_lpc.c **** 	USBCtrl = WR_EN | ((bEP & 0xF) << 2);
 483              		.loc 1 330 0
 484 01dc 0331A0E1 		mov	r3, r3, asl #2
 324:../LPCUSB/usbhw_lpc.c **** {
 485              		.loc 1 324 0
 486 01e0 10402DE9 		stmfd	sp!, {r4, lr}
 487              	.LCFI3:
 488              		.cfi_def_cfa_offset 8
 489              		.cfi_offset 14, -4
 490              		.cfi_offset 4, -8
 324:../LPCUSB/usbhw_lpc.c **** {
 491              		.loc 1 324 0
 492 01e4 0240A0E1 		mov	r4, r2
 493              		.loc 1 330 0
 494 01e8 022083E3 		orr	r2, r3, #2
 495              	.LVL32:
 496 01ec 54309FE5 		ldr	r3, .L35
 497 01f0 282083E5 		str	r2, [r3, #40]
 331:../LPCUSB/usbhw_lpc.c **** 	
 332:../LPCUSB/usbhw_lpc.c **** 	// set packet length
 333:../LPCUSB/usbhw_lpc.c **** 	USBTxPLen = iLen;
 498              		.loc 1 333 0
 499 01f4 244083E5 		str	r4, [r3, #36]
 334:../LPCUSB/usbhw_lpc.c **** 	
 335:../LPCUSB/usbhw_lpc.c **** 	// write data
 336:../LPCUSB/usbhw_lpc.c **** 	while (USBCtrl & WR_EN) {
 500              		.loc 1 336 0
 501 01f8 090000EA 		b	.L33
 502              	.L34:
 337:../LPCUSB/usbhw_lpc.c **** 		USBTxData = (pbBuf[3] << 24) | (pbBuf[2] << 16) | (pbBuf[1] << 8) | pbBuf[0];
 503              		.loc 1 337 0
 504 01fc 0220D1E5 		ldrb	r2, [r1, #2]	@ zero_extendqisi2
 505 0200 03C0D1E5 		ldrb	ip, [r1, #3]	@ zero_extendqisi2
 506 0204 0228A0E1 		mov	r2, r2, asl #16
 507 0208 0C2C82E1 		orr	r2, r2, ip, asl #24
 508 020c 00C0D1E5 		ldrb	ip, [r1, #0]	@ zero_extendqisi2
 509 0210 0C2082E1 		orr	r2, r2, ip
 510 0214 01C0D1E5 		ldrb	ip, [r1, #1]	@ zero_extendqisi2
 511 0218 0C2482E1 		orr	r2, r2, ip, asl #8
 512 021c 1C2083E5 		str	r2, [r3, #28]
 338:../LPCUSB/usbhw_lpc.c **** 		pbBuf += 4;
 513              		.loc 1 338 0
 514 0220 041081E2 		add	r1, r1, #4
 515              	.LVL33:
 516              	.L33:
 336:../LPCUSB/usbhw_lpc.c **** 	while (USBCtrl & WR_EN) {
 517              		.loc 1 336 0 discriminator 1
 518 0224 282093E5 		ldr	r2, [r3, #40]
 519 0228 020012E3 		tst	r2, #2
 520 022c F2FFFF1A 		bne	.L34
 339:../LPCUSB/usbhw_lpc.c **** 	}
 340:../LPCUSB/usbhw_lpc.c **** 
 341:../LPCUSB/usbhw_lpc.c **** 	// select endpoint and validate buffer
 342:../LPCUSB/usbhw_lpc.c **** 	USBHwCmd(CMD_EP_SELECT | idx);
 521              		.loc 1 342 0
 522 0230 7BFFFFEB 		bl	USBHwCmd
 523              	.LVL34:
 343:../LPCUSB/usbhw_lpc.c **** 	USBHwCmd(CMD_EP_VALIDATE_BUFFER);
 524              		.loc 1 343 0
 525 0234 FA00A0E3 		mov	r0, #250
 526 0238 79FFFFEB 		bl	USBHwCmd
 344:../LPCUSB/usbhw_lpc.c **** 	
 345:../LPCUSB/usbhw_lpc.c **** 	return iLen;
 346:../LPCUSB/usbhw_lpc.c **** }
 527              		.loc 1 346 0
 528 023c 0400A0E1 		mov	r0, r4
 529 0240 1040BDE8 		ldmfd	sp!, {r4, lr}
 530 0244 1EFF2FE1 		bx	lr
 531              	.L36:
 532              		.align	2
 533              	.L35:
 534 0248 000009E0 		.word	-536281088
 535              		.cfi_endproc
 536              	.LFE15:
 538              		.align	2
 539              		.global	USBHwEPRead
 541              	USBHwEPRead:
 542              	.LFB16:
 347:../LPCUSB/usbhw_lpc.c **** 
 348:../LPCUSB/usbhw_lpc.c **** 
 349:../LPCUSB/usbhw_lpc.c **** /**
 350:../LPCUSB/usbhw_lpc.c **** 	Reads data from an endpoint buffer
 351:../LPCUSB/usbhw_lpc.c **** 		
 352:../LPCUSB/usbhw_lpc.c **** 	@param [in]	bEP		Endpoint number
 353:../LPCUSB/usbhw_lpc.c **** 	@param [in]	pbBuf	Endpoint data
 354:../LPCUSB/usbhw_lpc.c **** 	@param [in]	iMaxLen	Maximum number of bytes to read
 355:../LPCUSB/usbhw_lpc.c **** 			
 356:../LPCUSB/usbhw_lpc.c **** 	@return the number of bytes available in the EP (possibly more than iMaxLen),
 357:../LPCUSB/usbhw_lpc.c **** 	or <0 in case of error.
 358:../LPCUSB/usbhw_lpc.c ****  */
 359:../LPCUSB/usbhw_lpc.c **** int USBHwEPRead(U8 bEP, U8 *pbBuf, int iMaxLen)
 360:../LPCUSB/usbhw_lpc.c **** {
 543              		.loc 1 360 0
 544              		.cfi_startproc
 545              		@ Function supports interworking.
 546              		@ args = 0, pretend = 0, frame = 0
 547              		@ frame_needed = 0, uses_anonymous_args = 0
 548              	.LVL35:
 549 024c 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 550              	.LCFI4:
 551              		.cfi_def_cfa_offset 16
 552              		.cfi_offset 14, -4
 553              		.cfi_offset 5, -8
 554              		.cfi_offset 4, -12
 555              		.cfi_offset 3, -16
 556              		.loc 1 360 0
 557 0250 0030A0E1 		mov	r3, r0
 361:../LPCUSB/usbhw_lpc.c **** 	int i, idx;
 362:../LPCUSB/usbhw_lpc.c **** 	U32	dwData, dwLen;
 363:../LPCUSB/usbhw_lpc.c **** 	
 364:../LPCUSB/usbhw_lpc.c **** 	idx = EP2IDX(bEP);
 558              		.loc 1 364 0
 559 0254 0F0000E2 		and	r0, r0, #15
 560              	.LVL36:
 365:../LPCUSB/usbhw_lpc.c **** 	
 366:../LPCUSB/usbhw_lpc.c **** 	// set read enable bit for specific endpoint
 367:../LPCUSB/usbhw_lpc.c **** 	USBCtrl = RD_EN | ((bEP & 0xF) << 2);
 561              		.loc 1 367 0
 562 0258 0041A0E1 		mov	r4, r0, asl #2
 563 025c 84C09FE5 		ldr	ip, .L46
 564 0260 014084E3 		orr	r4, r4, #1
 565 0264 28408CE5 		str	r4, [ip, #40]
 566              	.L38:
 368:../LPCUSB/usbhw_lpc.c **** 	
 369:../LPCUSB/usbhw_lpc.c **** 	// wait for PKT_RDY
 370:../LPCUSB/usbhw_lpc.c **** 	do {
 371:../LPCUSB/usbhw_lpc.c **** 		dwLen = USBRxPLen;
 567              		.loc 1 371 0 discriminator 1
 568 0268 20409CE5 		ldr	r4, [ip, #32]
 569              	.LVL37:
 372:../LPCUSB/usbhw_lpc.c **** 	} while ((dwLen & PKT_RDY) == 0);
 570              		.loc 1 372 0 discriminator 1
 571 026c 020B14E3 		tst	r4, #2048
 572 0270 FCFFFF0A 		beq	.L38
 373:../LPCUSB/usbhw_lpc.c **** 	
 374:../LPCUSB/usbhw_lpc.c **** 	// packet valid?
 375:../LPCUSB/usbhw_lpc.c **** 	if ((dwLen & DV) == 0) {
 573              		.loc 1 375 0
 574 0274 010B14E3 		tst	r4, #1024
 376:../LPCUSB/usbhw_lpc.c **** 		return -1;
 575              		.loc 1 376 0
 576 0278 0040E003 		mvneq	r4, #0
 577              	.LVL38:
 375:../LPCUSB/usbhw_lpc.c **** 	if ((dwLen & DV) == 0) {
 578              		.loc 1 375 0
 579 027c 1600000A 		beq	.L39
 580              	.LVL39:
 377:../LPCUSB/usbhw_lpc.c **** 	}
 378:../LPCUSB/usbhw_lpc.c **** 	
 379:../LPCUSB/usbhw_lpc.c **** 	// get length
 380:../LPCUSB/usbhw_lpc.c **** 	dwLen &= PKT_LNGTH_MASK;
 581              		.loc 1 380 0
 582 0280 044BA0E1 		mov	r4, r4, asl #22
 583              	.LVL40:
 381:../LPCUSB/usbhw_lpc.c **** 	
 382:../LPCUSB/usbhw_lpc.c **** 	// get data
 383:../LPCUSB/usbhw_lpc.c **** 	dwData = 0;
 584              		.loc 1 383 0
 585 0284 00E0A0E3 		mov	lr, #0
 380:../LPCUSB/usbhw_lpc.c **** 	dwLen &= PKT_LNGTH_MASK;
 586              		.loc 1 380 0
 587 0288 244BA0E1 		mov	r4, r4, lsr #22
 384:../LPCUSB/usbhw_lpc.c **** 	for (i = 0; i < dwLen; i++) {
 588              		.loc 1 384 0
 589 028c 0EC0A0E1 		mov	ip, lr
 385:../LPCUSB/usbhw_lpc.c **** 		if ((i % 4) == 0) {
 386:../LPCUSB/usbhw_lpc.c **** 			dwData = USBRxData;
 590              		.loc 1 386 0
 591 0290 50509FE5 		ldr	r5, .L46
 384:../LPCUSB/usbhw_lpc.c **** 	for (i = 0; i < dwLen; i++) {
 592              		.loc 1 384 0
 593 0294 060000EA 		b	.L40
 594              	.LVL41:
 595              	.L43:
 385:../LPCUSB/usbhw_lpc.c **** 		if ((i % 4) == 0) {
 596              		.loc 1 385 0
 597 0298 03001CE3 		tst	ip, #3
 598              		.loc 1 386 0
 599 029c 18E09505 		ldreq	lr, [r5, #24]
 600              	.LVL42:
 387:../LPCUSB/usbhw_lpc.c **** 		}
 388:../LPCUSB/usbhw_lpc.c **** 		if ((pbBuf != NULL) && (i < iMaxLen)) {
 601              		.loc 1 388 0
 602 02a0 000051E3 		cmp	r1, #0
 603 02a4 02005C11 		cmpne	ip, r2
 389:../LPCUSB/usbhw_lpc.c **** 			pbBuf[i] = dwData & 0xFF;
 604              		.loc 1 389 0
 605 02a8 0CE0C1B7 		strltb	lr, [r1, ip]
 390:../LPCUSB/usbhw_lpc.c **** 		}
 391:../LPCUSB/usbhw_lpc.c **** 		dwData >>= 8;
 606              		.loc 1 391 0
 607 02ac 2EE4A0E1 		mov	lr, lr, lsr #8
 608              	.LVL43:
 384:../LPCUSB/usbhw_lpc.c **** 	for (i = 0; i < dwLen; i++) {
 609              		.loc 1 384 0
 610 02b0 01C08CE2 		add	ip, ip, #1
 611              	.LVL44:
 612              	.L40:
 384:../LPCUSB/usbhw_lpc.c **** 	for (i = 0; i < dwLen; i++) {
 613              		.loc 1 384 0 is_stmt 0 discriminator 1
 614 02b4 04005CE1 		cmp	ip, r4
 615 02b8 F6FFFF1A 		bne	.L43
 392:../LPCUSB/usbhw_lpc.c **** 	}
 393:../LPCUSB/usbhw_lpc.c **** 
 394:../LPCUSB/usbhw_lpc.c **** 	// make sure RD_EN is clear
 395:../LPCUSB/usbhw_lpc.c **** 	USBCtrl = 0;
 616              		.loc 1 395 0 is_stmt 1
 617 02bc 24209FE5 		ldr	r2, .L46
 618              	.LVL45:
 619 02c0 0010A0E3 		mov	r1, #0
 620              	.LVL46:
 364:../LPCUSB/usbhw_lpc.c **** 	idx = EP2IDX(bEP);
 621              		.loc 1 364 0
 622 02c4 A333A0E1 		mov	r3, r3, lsr #7
 623              	.LVL47:
 396:../LPCUSB/usbhw_lpc.c **** 
 397:../LPCUSB/usbhw_lpc.c **** 	// select endpoint and clear buffer
 398:../LPCUSB/usbhw_lpc.c **** 	USBHwCmd(CMD_EP_SELECT | idx);
 624              		.loc 1 398 0
 625 02c8 800083E1 		orr	r0, r3, r0, asl #1
 395:../LPCUSB/usbhw_lpc.c **** 	USBCtrl = 0;
 626              		.loc 1 395 0
 627 02cc 281082E5 		str	r1, [r2, #40]
 628              		.loc 1 398 0
 629 02d0 53FFFFEB 		bl	USBHwCmd
 630              	.LVL48:
 399:../LPCUSB/usbhw_lpc.c **** 	USBHwCmd(CMD_EP_CLEAR_BUFFER);
 631              		.loc 1 399 0
 632 02d4 F200A0E3 		mov	r0, #242
 633 02d8 51FFFFEB 		bl	USBHwCmd
 634              	.L39:
 400:../LPCUSB/usbhw_lpc.c **** 	
 401:../LPCUSB/usbhw_lpc.c **** 	return dwLen;
 402:../LPCUSB/usbhw_lpc.c **** }
 635              		.loc 1 402 0
 636 02dc 0400A0E1 		mov	r0, r4
 637 02e0 3840BDE8 		ldmfd	sp!, {r3, r4, r5, lr}
 638 02e4 1EFF2FE1 		bx	lr
 639              	.L47:
 640              		.align	2
 641              	.L46:
 642 02e8 000009E0 		.word	-536281088
 643              		.cfi_endproc
 644              	.LFE16:
 646              		.align	2
 647              		.global	USBHwConfigDevice
 649              	USBHwConfigDevice:
 650              	.LFB17:
 403:../LPCUSB/usbhw_lpc.c **** 
 404:../LPCUSB/usbhw_lpc.c **** 
 405:../LPCUSB/usbhw_lpc.c **** /**
 406:../LPCUSB/usbhw_lpc.c **** 	Sets the 'configured' state.
 407:../LPCUSB/usbhw_lpc.c **** 		
 408:../LPCUSB/usbhw_lpc.c **** 	All registered endpoints are 'realised' and enabled, and the
 409:../LPCUSB/usbhw_lpc.c **** 	'configured' bit is set in the device status register.
 410:../LPCUSB/usbhw_lpc.c **** 		
 411:../LPCUSB/usbhw_lpc.c **** 	@param [in]	fConfigured	If TRUE, configure device, else unconfigure
 412:../LPCUSB/usbhw_lpc.c ****  */
 413:../LPCUSB/usbhw_lpc.c **** void USBHwConfigDevice(BOOL fConfigured)
 414:../LPCUSB/usbhw_lpc.c **** {
 651              		.loc 1 414 0
 652              		.cfi_startproc
 653              		@ Function supports interworking.
 654              		@ args = 0, pretend = 0, frame = 0
 655              		@ frame_needed = 0, uses_anonymous_args = 0
 656              		@ link register save eliminated.
 657              	.LVL49:
 415:../LPCUSB/usbhw_lpc.c **** 	// set configured bit
 416:../LPCUSB/usbhw_lpc.c **** 	USBHwCmdWrite(CMD_DEV_CONFIG, fConfigured ? CONF_DEVICE : 0);
 658              		.loc 1 416 0
 659 02ec 001090E2 		adds	r1, r0, #0
 660 02f0 0110A013 		movne	r1, #1
 661 02f4 D800A0E3 		mov	r0, #216
 662              	.LVL50:
 417:../LPCUSB/usbhw_lpc.c **** }
 663              		.loc 1 417 0
 416:../LPCUSB/usbhw_lpc.c **** 	USBHwCmdWrite(CMD_DEV_CONFIG, fConfigured ? CONF_DEVICE : 0);
 664              		.loc 1 416 0
 665 02f8 52FFFFEA 		b	USBHwCmdWrite
 666              		.cfi_endproc
 667              	.LFE17:
 669              		.align	2
 670              		.global	USBHwISR
 672              	USBHwISR:
 673              	.LFB18:
 418:../LPCUSB/usbhw_lpc.c **** 
 419:../LPCUSB/usbhw_lpc.c **** 
 420:../LPCUSB/usbhw_lpc.c **** /**
 421:../LPCUSB/usbhw_lpc.c **** 	USB interrupt handler
 422:../LPCUSB/usbhw_lpc.c **** 		
 423:../LPCUSB/usbhw_lpc.c **** 	@todo Get all 11 bits of frame number instead of just 8
 424:../LPCUSB/usbhw_lpc.c **** 
 425:../LPCUSB/usbhw_lpc.c **** 	Endpoint interrupts are mapped to the slow interrupt
 426:../LPCUSB/usbhw_lpc.c ****  */
 427:../LPCUSB/usbhw_lpc.c **** void USBHwISR(void)
 428:../LPCUSB/usbhw_lpc.c **** {
 674              		.loc 1 428 0
 675              		.cfi_startproc
 676              		@ Function supports interworking.
 677              		@ args = 0, pretend = 0, frame = 0
 678              		@ frame_needed = 0, uses_anonymous_args = 0
 679 02fc F8402DE9 		stmfd	sp!, {r3, r4, r5, r6, r7, lr}
 680              	.LCFI5:
 681              		.cfi_def_cfa_offset 24
 682              		.cfi_offset 14, -4
 683              		.cfi_offset 7, -8
 684              		.cfi_offset 6, -12
 685              		.cfi_offset 5, -16
 686              		.cfi_offset 4, -20
 687              		.cfi_offset 3, -24
 429:../LPCUSB/usbhw_lpc.c **** 	U32	dwStatus;
 430:../LPCUSB/usbhw_lpc.c **** 	U32 dwIntBit;
 431:../LPCUSB/usbhw_lpc.c **** 	U8	bEPStat, bDevStat, bStat;
 432:../LPCUSB/usbhw_lpc.c **** 	int i;
 433:../LPCUSB/usbhw_lpc.c **** 	U16	wFrame;
 434:../LPCUSB/usbhw_lpc.c **** 
 435:../LPCUSB/usbhw_lpc.c **** // LED9 monitors total time in interrupt routine
 436:../LPCUSB/usbhw_lpc.c **** DEBUG_LED_ON(9);
 437:../LPCUSB/usbhw_lpc.c **** 
 438:../LPCUSB/usbhw_lpc.c **** 	// handle device interrupts
 439:../LPCUSB/usbhw_lpc.c **** 	dwStatus = USBDevIntSt;
 688              		.loc 1 439 0
 689 0300 E0309FE5 		ldr	r3, .L56
 690 0304 004093E5 		ldr	r4, [r3, #0]
 691              	.LVL51:
 440:../LPCUSB/usbhw_lpc.c **** 	
 441:../LPCUSB/usbhw_lpc.c **** 	// frame interrupt
 442:../LPCUSB/usbhw_lpc.c **** 	if (dwStatus & FRAME) {
 692              		.loc 1 442 0
 693 0308 010014E3 		tst	r4, #1
 694 030c 0900000A 		beq	.L50
 443:../LPCUSB/usbhw_lpc.c **** 		// clear int
 444:../LPCUSB/usbhw_lpc.c **** 		USBDevIntClr = FRAME;
 695              		.loc 1 444 0
 696 0310 0120A0E3 		mov	r2, #1
 697 0314 082083E5 		str	r2, [r3, #8]
 445:../LPCUSB/usbhw_lpc.c **** 		// call handler
 446:../LPCUSB/usbhw_lpc.c **** 		if (_pfnFrameHandler != NULL) {
 698              		.loc 1 446 0
 699 0318 CC309FE5 		ldr	r3, .L56+4
 700 031c 445093E5 		ldr	r5, [r3, #68]
 701 0320 000055E3 		cmp	r5, #0
 702 0324 0300000A 		beq	.L50
 447:../LPCUSB/usbhw_lpc.c **** 			wFrame = USBHwCmdRead(CMD_DEV_READ_CUR_FRAME_NR);
 703              		.loc 1 447 0
 704 0328 F500A0E3 		mov	r0, #245
 705 032c 50FFFFEB 		bl	USBHwCmdRead
 706              	.LVL52:
 448:../LPCUSB/usbhw_lpc.c **** 			_pfnFrameHandler(wFrame);
 707              		.loc 1 448 0
 708 0330 0FE0A0E1 		mov	lr, pc
 709 0334 15FF2FE1 		bx	r5
 710              	.LVL53:
 711              	.L50:
 449:../LPCUSB/usbhw_lpc.c **** 		}
 450:../LPCUSB/usbhw_lpc.c **** 	}
 451:../LPCUSB/usbhw_lpc.c **** 	
 452:../LPCUSB/usbhw_lpc.c **** 	// device status interrupt
 453:../LPCUSB/usbhw_lpc.c **** 	if (dwStatus & DEV_STAT) {
 712              		.loc 1 453 0
 713 0338 080014E3 		tst	r4, #8
 714 033c 0C00000A 		beq	.L51
 454:../LPCUSB/usbhw_lpc.c **** 		/*	Clear DEV_STAT interrupt before reading DEV_STAT register.
 455:../LPCUSB/usbhw_lpc.c **** 			This prevents corrupted device status reads, see
 456:../LPCUSB/usbhw_lpc.c **** 			LPC2148 User manual revision 2, 25 july 2006.
 457:../LPCUSB/usbhw_lpc.c **** 		*/
 458:../LPCUSB/usbhw_lpc.c **** 		USBDevIntClr = DEV_STAT;
 715              		.loc 1 458 0
 716 0340 A0309FE5 		ldr	r3, .L56
 717 0344 0820A0E3 		mov	r2, #8
 718 0348 082083E5 		str	r2, [r3, #8]
 459:../LPCUSB/usbhw_lpc.c **** 		bDevStat = USBHwCmdRead(CMD_DEV_STATUS);
 719              		.loc 1 459 0
 720 034c FE00A0E3 		mov	r0, #254
 721 0350 47FFFFEB 		bl	USBHwCmdRead
 722              	.LVL54:
 460:../LPCUSB/usbhw_lpc.c **** 		if (bDevStat & (CON_CH | SUS_CH | RST)) {
 723              		.loc 1 460 0
 724 0354 1A0010E3 		tst	r0, #26
 725 0358 0500000A 		beq	.L51
 726              	.LVL55:
 461:../LPCUSB/usbhw_lpc.c **** 			// convert device status into something HW independent
 462:../LPCUSB/usbhw_lpc.c **** 			bStat = ((bDevStat & CON) ? DEV_STATUS_CONNECT : 0) |
 463:../LPCUSB/usbhw_lpc.c **** 					((bDevStat & SUS) ? DEV_STATUS_SUSPEND : 0) |
 464:../LPCUSB/usbhw_lpc.c **** 					((bDevStat & RST) ? DEV_STATUS_RESET : 0);
 465:../LPCUSB/usbhw_lpc.c **** 			// call handler
 466:../LPCUSB/usbhw_lpc.c **** 			if (_pfnDevIntHandler != NULL) {
 727              		.loc 1 466 0
 728 035c 88309FE5 		ldr	r3, .L56+4
 729 0360 403093E5 		ldr	r3, [r3, #64]
 730 0364 000053E3 		cmp	r3, #0
 467:../LPCUSB/usbhw_lpc.c **** DEBUG_LED_ON(8);		
 468:../LPCUSB/usbhw_lpc.c **** 				_pfnDevIntHandler(bStat);
 731              		.loc 1 468 0
 732 0368 15000012 		andne	r0, r0, #21
 733              	.LVL56:
 734 036c 0FE0A011 		movne	lr, pc
 735 0370 13FF2F11 		bxne	r3
 736              	.L51:
 469:../LPCUSB/usbhw_lpc.c **** DEBUG_LED_OFF(8);		
 470:../LPCUSB/usbhw_lpc.c **** 			}
 471:../LPCUSB/usbhw_lpc.c **** 		}
 472:../LPCUSB/usbhw_lpc.c **** 	}
 473:../LPCUSB/usbhw_lpc.c **** 	
 474:../LPCUSB/usbhw_lpc.c **** 	// endpoint interrupt
 475:../LPCUSB/usbhw_lpc.c **** 	if (dwStatus & EP_SLOW) {
 737              		.loc 1 475 0
 738 0374 040014E3 		tst	r4, #4
 739 0378 1800000A 		beq	.L49
 476:../LPCUSB/usbhw_lpc.c **** 		// clear EP_SLOW
 477:../LPCUSB/usbhw_lpc.c **** 		USBDevIntClr = EP_SLOW;
 740              		.loc 1 477 0
 741 037c 64509FE5 		ldr	r5, .L56
 742 0380 0430A0E3 		mov	r3, #4
 743 0384 083085E5 		str	r3, [r5, #8]
 744              	.LVL57:
 478:../LPCUSB/usbhw_lpc.c **** 		// check all endpoints
 479:../LPCUSB/usbhw_lpc.c **** 		for (i = 0; i < 32; i++) {
 480:../LPCUSB/usbhw_lpc.c **** 			dwIntBit = (1 << i);
 481:../LPCUSB/usbhw_lpc.c **** 			if (USBEpIntSt & dwIntBit) {
 482:../LPCUSB/usbhw_lpc.c **** 				// clear int (and retrieve status)
 483:../LPCUSB/usbhw_lpc.c **** 				USBEpIntClr = dwIntBit;
 484:../LPCUSB/usbhw_lpc.c **** 				Wait4DevInt(CDFULL);
 485:../LPCUSB/usbhw_lpc.c **** 				bEPStat = USBCmdData;
 486:../LPCUSB/usbhw_lpc.c **** 				// convert EP pipe stat into something HW independent
 487:../LPCUSB/usbhw_lpc.c **** 				bStat = ((bEPStat & EPSTAT_FE) ? EP_STATUS_DATA : 0) |
 488:../LPCUSB/usbhw_lpc.c **** 						((bEPStat & EPSTAT_ST) ? EP_STATUS_STALLED : 0) |
 489:../LPCUSB/usbhw_lpc.c **** 						((bEPStat & EPSTAT_STP) ? EP_STATUS_SETUP : 0) |
 490:../LPCUSB/usbhw_lpc.c **** 						((bEPStat & EPSTAT_EPN) ? EP_STATUS_NACKED : 0) |
 491:../LPCUSB/usbhw_lpc.c **** 						((bEPStat & EPSTAT_PO) ? EP_STATUS_ERROR : 0);
 492:../LPCUSB/usbhw_lpc.c **** 				// call handler
 493:../LPCUSB/usbhw_lpc.c **** 				if (_apfnEPIntHandlers[i / 2] != NULL) {
 745              		.loc 1 493 0
 746 0388 5C609FE5 		ldr	r6, .L56+4
 479:../LPCUSB/usbhw_lpc.c **** 		for (i = 0; i < 32; i++) {
 747              		.loc 1 479 0
 748 038c 0040A0E3 		mov	r4, #0
 749              	.LVL58:
 480:../LPCUSB/usbhw_lpc.c **** 			dwIntBit = (1 << i);
 750              		.loc 1 480 0
 751 0390 0170A0E3 		mov	r7, #1
 752              	.LVL59:
 753              	.L54:
 754 0394 1734A0E1 		mov	r3, r7, asl r4
 755              	.LVL60:
 481:../LPCUSB/usbhw_lpc.c **** 			if (USBEpIntSt & dwIntBit) {
 756              		.loc 1 481 0
 757 0398 302095E5 		ldr	r2, [r5, #48]
 758 039c 020013E1 		tst	r3, r2
 759 03a0 0B00000A 		beq	.L53
 483:../LPCUSB/usbhw_lpc.c **** 				USBEpIntClr = dwIntBit;
 760              		.loc 1 483 0
 761 03a4 383085E5 		str	r3, [r5, #56]
 484:../LPCUSB/usbhw_lpc.c **** 				Wait4DevInt(CDFULL);
 762              		.loc 1 484 0
 763 03a8 2000A0E3 		mov	r0, #32
 764 03ac 13FFFFEB 		bl	Wait4DevInt
 765              	.LVL61:
 766              		.loc 1 493 0
 767 03b0 C400A0E1 		mov	r0, r4, asr #1
 768 03b4 003196E7 		ldr	r3, [r6, r0, asl #2]
 769 03b8 000053E3 		cmp	r3, #0
 485:../LPCUSB/usbhw_lpc.c **** 				bEPStat = USBCmdData;
 770              		.loc 1 485 0
 771 03bc 141095E5 		ldr	r1, [r5, #20]
 772              	.LVL62:
 773              		.loc 1 493 0
 494:../LPCUSB/usbhw_lpc.c **** DEBUG_LED_ON(10);		
 495:../LPCUSB/usbhw_lpc.c **** 					_apfnEPIntHandlers[i / 2](IDX2EP(i), bStat);
 774              		.loc 1 495 0
 775 03c0 84038011 		orrne	r0, r0, r4, asl #7
 776 03c4 FF000012 		andne	r0, r0, #255
 777 03c8 1F100112 		andne	r1, r1, #31
 778              	.LVL63:
 779 03cc 0FE0A011 		movne	lr, pc
 780 03d0 13FF2F11 		bxne	r3
 781              	.L53:
 479:../LPCUSB/usbhw_lpc.c **** 		for (i = 0; i < 32; i++) {
 782              		.loc 1 479 0
 783 03d4 014084E2 		add	r4, r4, #1
 784              	.LVL64:
 785 03d8 200054E3 		cmp	r4, #32
 786 03dc ECFFFF1A 		bne	.L54
 787              	.LVL65:
 788              	.L49:
 496:../LPCUSB/usbhw_lpc.c **** DEBUG_LED_OFF(10);
 497:../LPCUSB/usbhw_lpc.c **** 				}
 498:../LPCUSB/usbhw_lpc.c **** 			}
 499:../LPCUSB/usbhw_lpc.c **** 		}
 500:../LPCUSB/usbhw_lpc.c **** 	}
 501:../LPCUSB/usbhw_lpc.c **** 	
 502:../LPCUSB/usbhw_lpc.c **** DEBUG_LED_OFF(9);		
 503:../LPCUSB/usbhw_lpc.c **** }
 789              		.loc 1 503 0
 790 03e0 F840BDE8 		ldmfd	sp!, {r3, r4, r5, r6, r7, lr}
 791 03e4 1EFF2FE1 		bx	lr
 792              	.L57:
 793              		.align	2
 794              	.L56:
 795 03e8 000009E0 		.word	-536281088
 796 03ec 00000000 		.word	.LANCHOR0
 797              		.cfi_endproc
 798              	.LFE18:
 800              		.align	2
 801              		.global	USBHwInit
 803              	USBHwInit:
 804              	.LFB19:
 504:../LPCUSB/usbhw_lpc.c **** 
 505:../LPCUSB/usbhw_lpc.c **** 
 506:../LPCUSB/usbhw_lpc.c **** 
 507:../LPCUSB/usbhw_lpc.c **** /**
 508:../LPCUSB/usbhw_lpc.c **** 	Initialises the USB hardware
 509:../LPCUSB/usbhw_lpc.c **** 		
 510:../LPCUSB/usbhw_lpc.c **** 	This function assumes that the hardware is connected as shown in
 511:../LPCUSB/usbhw_lpc.c **** 	section 10.1 of the LPC2148 data sheet:
 512:../LPCUSB/usbhw_lpc.c **** 	* P0.31 controls a switch to connect a 1.5k pull-up to D+ if low.
 513:../LPCUSB/usbhw_lpc.c **** 	* P0.23 is connected to USB VCC.
 514:../LPCUSB/usbhw_lpc.c **** 	
 515:../LPCUSB/usbhw_lpc.c **** 	Embedded artists board: make sure to disconnect P0.23 LED as it
 516:../LPCUSB/usbhw_lpc.c **** 	acts as a pull-up and so prevents detection of USB disconnect.
 517:../LPCUSB/usbhw_lpc.c **** 		
 518:../LPCUSB/usbhw_lpc.c **** 	@return TRUE if the hardware was successfully initialised
 519:../LPCUSB/usbhw_lpc.c ****  */
 520:../LPCUSB/usbhw_lpc.c **** BOOL USBHwInit(void)
 521:../LPCUSB/usbhw_lpc.c **** {
 805              		.loc 1 521 0
 806              		.cfi_startproc
 807              		@ Function supports interworking.
 808              		@ args = 0, pretend = 0, frame = 0
 809              		@ frame_needed = 0, uses_anonymous_args = 0
 810 03f0 08402DE9 		stmfd	sp!, {r3, lr}
 811              	.LCFI6:
 812              		.cfi_def_cfa_offset 8
 813              		.cfi_offset 14, -4
 814              		.cfi_offset 3, -8
 522:../LPCUSB/usbhw_lpc.c **** 	// configure P0.23 for Vbus sense
 523:../LPCUSB/usbhw_lpc.c **** 	PINSEL1 = (PINSEL1 & ~(3 << 14)) | (1 << 14);	// P0.23
 815              		.loc 1 523 0
 816 03f4 A8309FE5 		ldr	r3, .L61
 817 03f8 042093E5 		ldr	r2, [r3, #4]
 818 03fc 0329C2E3 		bic	r2, r2, #49152
 819 0400 012982E3 		orr	r2, r2, #16384
 820 0404 042083E5 		str	r2, [r3, #4]
 524:../LPCUSB/usbhw_lpc.c **** 	// configure P0.31 for CONNECT
 525:../LPCUSB/usbhw_lpc.c **** 	PINSEL1 = (PINSEL1 & ~(3 << 30)) | (2 << 30);	// P0.31
 821              		.loc 1 525 0
 822 0408 042093E5 		ldr	r2, [r3, #4]
 823 040c 0321C2E3 		bic	r2, r2, #-1073741824
 824 0410 022182E3 		orr	r2, r2, #-2147483648
 825 0414 042083E5 		str	r2, [r3, #4]
 526:../LPCUSB/usbhw_lpc.c **** 
 527:../LPCUSB/usbhw_lpc.c **** 	// enable PUSB
 528:../LPCUSB/usbhw_lpc.c **** 	PCONP |= (1 << 31);		
 826              		.loc 1 528 0
 827 0418 1D3883E2 		add	r3, r3, #1900544
 828 041c C42093E5 		ldr	r2, [r3, #196]
 829 0420 022182E3 		orr	r2, r2, #-2147483648
 830 0424 C42083E5 		str	r2, [r3, #196]
 529:../LPCUSB/usbhw_lpc.c **** 	
 530:../LPCUSB/usbhw_lpc.c **** 	// initialise PLL
 531:../LPCUSB/usbhw_lpc.c **** 	PLL1CON = 1;			// enable PLL
 831              		.loc 1 531 0
 832 0428 0120A0E3 		mov	r2, #1
 833 042c A02083E5 		str	r2, [r3, #160]
 532:../LPCUSB/usbhw_lpc.c **** 	PLL1CFG = (1 << 5) | 3; // P = 2, M = 4
 834              		.loc 1 532 0
 835 0430 2320A0E3 		mov	r2, #35
 836 0434 A42083E5 		str	r2, [r3, #164]
 533:../LPCUSB/usbhw_lpc.c **** 	PLL1FEED = 0xAA;
 837              		.loc 1 533 0
 838 0438 AA20A0E3 		mov	r2, #170
 839 043c AC2083E5 		str	r2, [r3, #172]
 534:../LPCUSB/usbhw_lpc.c **** 	PLL1FEED = 0x55;
 840              		.loc 1 534 0
 841 0440 5520A0E3 		mov	r2, #85
 842 0444 AC2083E5 		str	r2, [r3, #172]
 843              	.L59:
 535:../LPCUSB/usbhw_lpc.c **** 	while ((PLL1STAT & (1 << 10)) == 0);
 844              		.loc 1 535 0 discriminator 1
 845 0448 A81093E5 		ldr	r1, [r3, #168]
 846 044c 010B11E3 		tst	r1, #1024
 847 0450 50209FE5 		ldr	r2, .L61+4
 848 0454 FBFFFF0A 		beq	.L59
 536:../LPCUSB/usbhw_lpc.c **** 
 537:../LPCUSB/usbhw_lpc.c **** 	PLL1CON = 3;			// enable and connect
 849              		.loc 1 537 0
 850 0458 0330A0E3 		mov	r3, #3
 851 045c A03082E5 		str	r3, [r2, #160]
 538:../LPCUSB/usbhw_lpc.c **** 	PLL1FEED = 0xAA;
 852              		.loc 1 538 0
 853 0460 AA30A0E3 		mov	r3, #170
 854 0464 AC3082E5 		str	r3, [r2, #172]
 539:../LPCUSB/usbhw_lpc.c **** 	PLL1FEED = 0x55;
 855              		.loc 1 539 0
 856 0468 5530A0E3 		mov	r3, #85
 857 046c AC3082E5 		str	r3, [r2, #172]
 540:../LPCUSB/usbhw_lpc.c **** 	
 541:../LPCUSB/usbhw_lpc.c **** 	// disable/clear all interrupts for now
 542:../LPCUSB/usbhw_lpc.c **** 	USBDevIntEn = 0;
 858              		.loc 1 542 0
 859 0470 34309FE5 		ldr	r3, .L61+8
 860 0474 0000A0E3 		mov	r0, #0
 543:../LPCUSB/usbhw_lpc.c **** 	USBDevIntClr = 0xFFFFFFFF;
 861              		.loc 1 543 0
 862 0478 0020E0E3 		mvn	r2, #0
 542:../LPCUSB/usbhw_lpc.c **** 	USBDevIntEn = 0;
 863              		.loc 1 542 0
 864 047c 040083E5 		str	r0, [r3, #4]
 865              		.loc 1 543 0
 866 0480 082083E5 		str	r2, [r3, #8]
 544:../LPCUSB/usbhw_lpc.c **** 	USBDevIntPri = 0;
 867              		.loc 1 544 0
 868 0484 2C0083E5 		str	r0, [r3, #44]
 545:../LPCUSB/usbhw_lpc.c **** 
 546:../LPCUSB/usbhw_lpc.c **** 	USBEpIntEn = 0;
 869              		.loc 1 546 0
 870 0488 340083E5 		str	r0, [r3, #52]
 547:../LPCUSB/usbhw_lpc.c **** 	USBEpIntClr = 0xFFFFFFFF;
 871              		.loc 1 547 0
 872 048c 382083E5 		str	r2, [r3, #56]
 548:../LPCUSB/usbhw_lpc.c **** 	USBEpIntPri = 0;
 873              		.loc 1 548 0
 874 0490 400083E5 		str	r0, [r3, #64]
 549:../LPCUSB/usbhw_lpc.c **** 
 550:../LPCUSB/usbhw_lpc.c **** 	// by default, only ACKs generate interrupts
 551:../LPCUSB/usbhw_lpc.c **** 	USBHwNakIntEnable(0);
 875              		.loc 1 551 0
 876 0494 FEFFFFEB 		bl	USBHwNakIntEnable
 552:../LPCUSB/usbhw_lpc.c **** 	
 553:../LPCUSB/usbhw_lpc.c **** 	// init debug leds
 554:../LPCUSB/usbhw_lpc.c **** 	DEBUG_LED_INIT(8);
 555:../LPCUSB/usbhw_lpc.c **** 	DEBUG_LED_INIT(9);
 556:../LPCUSB/usbhw_lpc.c **** 	DEBUG_LED_INIT(10);
 557:../LPCUSB/usbhw_lpc.c **** 
 558:../LPCUSB/usbhw_lpc.c **** 	return TRUE;
 559:../LPCUSB/usbhw_lpc.c **** }
 877              		.loc 1 559 0
 878 0498 0100A0E3 		mov	r0, #1
 879 049c 0840BDE8 		ldmfd	sp!, {r3, lr}
 880 04a0 1EFF2FE1 		bx	lr
 881              	.L62:
 882              		.align	2
 883              	.L61:
 884 04a4 00C002E0 		.word	-536690688
 885 04a8 00C01FE0 		.word	-534790144
 886 04ac 000009E0 		.word	-536281088
 887              		.cfi_endproc
 888              	.LFE19:
 890              		.bss
 891              		.align	2
 892              		.set	.LANCHOR0,. + 0
 895              	_apfnEPIntHandlers:
 896 0000 00000000 		.space	64
 896      00000000 
 896      00000000 
 896      00000000 
 896      00000000 
 899              	_pfnDevIntHandler:
 900 0040 00000000 		.space	4
 903              	_pfnFrameHandler:
 904 0044 00000000 		.space	4
 905              		.text
 906              	.Letext0:
 907              		.file 2 "../LPCUSB/type.h"
 908              		.file 3 "../LPCUSB/usbapi.h"
DEFINED SYMBOLS
                            *ABS*:00000000 usbhw_lpc.c
     /tmp/ccNTLrEp.s:16     .text:00000000 $a
     /tmp/ccNTLrEp.s:18     .text:00000000 Wait4DevInt
     /tmp/ccNTLrEp.s:44     .text:00000020 $d
     /tmp/ccNTLrEp.s:48     .text:00000024 $a
     /tmp/ccNTLrEp.s:50     .text:00000024 USBHwCmd
     /tmp/ccNTLrEp.s:80     .text:00000044 $d
     /tmp/ccNTLrEp.s:84     .text:00000048 $a
     /tmp/ccNTLrEp.s:86     .text:00000048 USBHwCmdWrite
     /tmp/ccNTLrEp.s:119    .text:00000070 $d
     /tmp/ccNTLrEp.s:123    .text:00000074 $a
     /tmp/ccNTLrEp.s:125    .text:00000074 USBHwCmdRead
     /tmp/ccNTLrEp.s:163    .text:000000a8 $d
     /tmp/ccNTLrEp.s:167    .text:000000ac $a
     /tmp/ccNTLrEp.s:170    .text:000000ac USBHwEPConfig
     /tmp/ccNTLrEp.s:236    .text:000000f0 $d
     /tmp/ccNTLrEp.s:242    .text:000000f4 $a
     /tmp/ccNTLrEp.s:245    .text:000000f4 USBHwRegisterEPIntHandler
     /tmp/ccNTLrEp.s:281    .text:0000012c $d
     /tmp/ccNTLrEp.s:286    .text:00000134 $a
     /tmp/ccNTLrEp.s:289    .text:00000134 USBHwRegisterDevIntHandler
     /tmp/ccNTLrEp.s:311    .text:00000150 $d
     /tmp/ccNTLrEp.s:316    .text:00000158 $a
     /tmp/ccNTLrEp.s:319    .text:00000158 USBHwRegisterFrameHandler
     /tmp/ccNTLrEp.s:341    .text:00000174 $d
     /tmp/ccNTLrEp.s:346    .text:0000017c $a
     /tmp/ccNTLrEp.s:349    .text:0000017c USBHwSetAddress
     /tmp/ccNTLrEp.s:371    .text:00000188 USBHwConnect
     /tmp/ccNTLrEp.s:394    .text:00000198 USBHwNakIntEnable
     /tmp/ccNTLrEp.s:417    .text:000001a4 USBHwEPGetStatus
     /tmp/ccNTLrEp.s:441    .text:000001b4 USBHwEPStall
     /tmp/ccNTLrEp.s:469    .text:000001d0 USBHwEPWrite
     /tmp/ccNTLrEp.s:534    .text:00000248 $d
     /tmp/ccNTLrEp.s:538    .text:0000024c $a
     /tmp/ccNTLrEp.s:541    .text:0000024c USBHwEPRead
     /tmp/ccNTLrEp.s:642    .text:000002e8 $d
     /tmp/ccNTLrEp.s:646    .text:000002ec $a
     /tmp/ccNTLrEp.s:649    .text:000002ec USBHwConfigDevice
     /tmp/ccNTLrEp.s:672    .text:000002fc USBHwISR
     /tmp/ccNTLrEp.s:795    .text:000003e8 $d
     /tmp/ccNTLrEp.s:800    .text:000003f0 $a
     /tmp/ccNTLrEp.s:803    .text:000003f0 USBHwInit
     /tmp/ccNTLrEp.s:884    .text:000004a4 $d
     /tmp/ccNTLrEp.s:891    .bss:00000000 $d
     /tmp/ccNTLrEp.s:895    .bss:00000000 _apfnEPIntHandlers
     /tmp/ccNTLrEp.s:899    .bss:00000040 _pfnDevIntHandler
     /tmp/ccNTLrEp.s:903    .bss:00000044 _pfnFrameHandler
                     .debug_frame:00000010 $d

NO UNDEFINED SYMBOLS
