   1              		.cpu arm7tdmi-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 4
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"usbstdreq.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  17              		.global	USBRegisterDescriptors
  19              	USBRegisterDescriptors:
  20              	.LFB0:
  21              		.file 1 "../LPCUSB/usbstdreq.c"
   1:../LPCUSB/usbstdreq.c **** /*
   2:../LPCUSB/usbstdreq.c **** 	LPCUSB, an USB device driver for LPC microcontrollers	
   3:../LPCUSB/usbstdreq.c **** 	Copyright (C) 2006 Bertrik Sikken (bertrik@sikken.nl)
   4:../LPCUSB/usbstdreq.c **** 
   5:../LPCUSB/usbstdreq.c **** 	Redistribution and use in source and binary forms, with or without
   6:../LPCUSB/usbstdreq.c **** 	modification, are permitted provided that the following conditions are met:
   7:../LPCUSB/usbstdreq.c **** 
   8:../LPCUSB/usbstdreq.c **** 	1. Redistributions of source code must retain the above copyright
   9:../LPCUSB/usbstdreq.c **** 	   notice, this list of conditions and the following disclaimer.
  10:../LPCUSB/usbstdreq.c **** 	2. Redistributions in binary form must reproduce the above copyright
  11:../LPCUSB/usbstdreq.c **** 	   notice, this list of conditions and the following disclaimer in the
  12:../LPCUSB/usbstdreq.c **** 	   documentation and/or other materials provided with the distribution.
  13:../LPCUSB/usbstdreq.c **** 	3. The name of the author may not be used to endorse or promote products
  14:../LPCUSB/usbstdreq.c **** 	   derived from this software without specific prior written permission.
  15:../LPCUSB/usbstdreq.c **** 
  16:../LPCUSB/usbstdreq.c **** 	THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
  17:../LPCUSB/usbstdreq.c **** 	IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  18:../LPCUSB/usbstdreq.c **** 	OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  19:../LPCUSB/usbstdreq.c **** 	IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, 
  20:../LPCUSB/usbstdreq.c **** 	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  21:../LPCUSB/usbstdreq.c **** 	NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  22:../LPCUSB/usbstdreq.c **** 	DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  23:../LPCUSB/usbstdreq.c **** 	THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  24:../LPCUSB/usbstdreq.c **** 	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  25:../LPCUSB/usbstdreq.c **** 	THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  26:../LPCUSB/usbstdreq.c **** */
  27:../LPCUSB/usbstdreq.c **** 
  28:../LPCUSB/usbstdreq.c **** 
  29:../LPCUSB/usbstdreq.c **** /** @file
  30:../LPCUSB/usbstdreq.c **** 	Standard request handler.
  31:../LPCUSB/usbstdreq.c **** 	
  32:../LPCUSB/usbstdreq.c **** 	This modules handles the 'chapter 9' processing, specifically the
  33:../LPCUSB/usbstdreq.c **** 	standard device requests in table 9-3 from the universal serial bus
  34:../LPCUSB/usbstdreq.c **** 	specification revision 2.0
  35:../LPCUSB/usbstdreq.c **** 	
  36:../LPCUSB/usbstdreq.c **** 	Specific types of devices may specify additional requests (for example
  37:../LPCUSB/usbstdreq.c **** 	HID devices add a GET_DESCRIPTOR request for interfaces), but they
  38:../LPCUSB/usbstdreq.c **** 	will not be part of this module.
  39:../LPCUSB/usbstdreq.c **** 
  40:../LPCUSB/usbstdreq.c **** 	@todo some requests have to return a request error if device not configured:
  41:../LPCUSB/usbstdreq.c **** 	@todo GET_INTERFACE, GET_STATUS, SET_INTERFACE, SYNCH_FRAME
  42:../LPCUSB/usbstdreq.c **** 	@todo this applies to the following if endpoint != 0:
  43:../LPCUSB/usbstdreq.c **** 	@todo SET_FEATURE, GET_FEATURE 
  44:../LPCUSB/usbstdreq.c **** */
  45:../LPCUSB/usbstdreq.c **** 
  46:../LPCUSB/usbstdreq.c **** #include "type.h"
  47:../LPCUSB/usbstdreq.c **** #include "usbdebug.h"
  48:../LPCUSB/usbstdreq.c **** #include "usbstruct.h"
  49:../LPCUSB/usbstdreq.c **** #include "usbapi.h"
  50:../LPCUSB/usbstdreq.c **** 
  51:../LPCUSB/usbstdreq.c **** #define MAX_DESC_HANDLERS	4		/**< device, interface, endpoint, other */
  52:../LPCUSB/usbstdreq.c **** 
  53:../LPCUSB/usbstdreq.c **** 
  54:../LPCUSB/usbstdreq.c **** /* general descriptor field offsets */
  55:../LPCUSB/usbstdreq.c **** #define DESC_bLength					0	/**< length offset */
  56:../LPCUSB/usbstdreq.c **** #define DESC_bDescriptorType			1	/**< descriptor type offset */	
  57:../LPCUSB/usbstdreq.c **** 
  58:../LPCUSB/usbstdreq.c **** /* config descriptor field offsets */
  59:../LPCUSB/usbstdreq.c **** #define CONF_DESC_wTotalLength			2	/**< total length offset */
  60:../LPCUSB/usbstdreq.c **** #define CONF_DESC_bConfigurationValue	5	/**< configuration value offset */	
  61:../LPCUSB/usbstdreq.c **** #define CONF_DESC_bmAttributes			7	/**< configuration characteristics */
  62:../LPCUSB/usbstdreq.c **** 
  63:../LPCUSB/usbstdreq.c **** /* interface descriptor field offsets */
  64:../LPCUSB/usbstdreq.c **** #define INTF_DESC_bAlternateSetting		3	/**< alternate setting offset */
  65:../LPCUSB/usbstdreq.c **** 
  66:../LPCUSB/usbstdreq.c **** /* endpoint descriptor field offsets */
  67:../LPCUSB/usbstdreq.c **** #define ENDP_DESC_bEndpointAddress		2	/**< endpoint address offset */
  68:../LPCUSB/usbstdreq.c **** #define ENDP_DESC_wMaxPacketSize		4	/**< maximum packet size offset */
  69:../LPCUSB/usbstdreq.c **** 
  70:../LPCUSB/usbstdreq.c **** 
  71:../LPCUSB/usbstdreq.c **** /** Currently selected configuration */
  72:../LPCUSB/usbstdreq.c **** static U8				bConfiguration = 0;
  73:../LPCUSB/usbstdreq.c **** /** Installed custom request handler */
  74:../LPCUSB/usbstdreq.c **** static TFnHandleRequest	*pfnHandleCustomReq = NULL;
  75:../LPCUSB/usbstdreq.c **** /** Pointer to registered descriptors */
  76:../LPCUSB/usbstdreq.c **** //static const U8			*pabDescrip = NULL;
  77:../LPCUSB/usbstdreq.c **** static U8			*pabDescrip = NULL;
  78:../LPCUSB/usbstdreq.c **** 
  79:../LPCUSB/usbstdreq.c **** 
  80:../LPCUSB/usbstdreq.c **** /**
  81:../LPCUSB/usbstdreq.c **** 	Registers a pointer to a descriptor block containing all descriptors
  82:../LPCUSB/usbstdreq.c **** 	for the device.
  83:../LPCUSB/usbstdreq.c **** 
  84:../LPCUSB/usbstdreq.c **** 	@param [in]	pabDescriptors	The descriptor byte array
  85:../LPCUSB/usbstdreq.c ****  */
  86:../LPCUSB/usbstdreq.c **** //void USBRegisterDescriptors(const U8 *pabDescriptors)
  87:../LPCUSB/usbstdreq.c **** void USBRegisterDescriptors(U8 *pabDescriptors)
  88:../LPCUSB/usbstdreq.c **** {
  22              		.loc 1 88 0
  23              		.cfi_startproc
  24              		@ Function supports interworking.
  25              		@ args = 0, pretend = 0, frame = 0
  26              		@ frame_needed = 0, uses_anonymous_args = 0
  27              		@ link register save eliminated.
  28              	.LVL0:
  89:../LPCUSB/usbstdreq.c **** 	pabDescrip = pabDescriptors;
  29              		.loc 1 89 0
  30 0000 04309FE5 		ldr	r3, .L2
  31 0004 000083E5 		str	r0, [r3, #0]
  90:../LPCUSB/usbstdreq.c **** }
  32              		.loc 1 90 0
  33 0008 1EFF2FE1 		bx	lr
  34              	.L3:
  35              		.align	2
  36              	.L2:
  37 000c 00000000 		.word	.LANCHOR0
  38              		.cfi_endproc
  39              	.LFE0:
  41              		.align	2
  42              		.global	USBGetDescriptor
  44              	USBGetDescriptor:
  45              	.LFB1:
  91:../LPCUSB/usbstdreq.c **** 
  92:../LPCUSB/usbstdreq.c **** 
  93:../LPCUSB/usbstdreq.c **** /**
  94:../LPCUSB/usbstdreq.c **** 	Parses the list of installed USB descriptors and attempts to find
  95:../LPCUSB/usbstdreq.c **** 	the specified USB descriptor.
  96:../LPCUSB/usbstdreq.c **** 		
  97:../LPCUSB/usbstdreq.c **** 	@param [in]		wTypeIndex	Type and index of the descriptor
  98:../LPCUSB/usbstdreq.c **** 	@param [in]		wLangID		Language ID of the descriptor (currently unused)
  99:../LPCUSB/usbstdreq.c **** 	@param [out]	*piLen		Descriptor length
 100:../LPCUSB/usbstdreq.c **** 	@param [out]	*ppbData	Descriptor data
 101:../LPCUSB/usbstdreq.c **** 	
 102:../LPCUSB/usbstdreq.c **** 	@return TRUE if the descriptor was found, FALSE otherwise
 103:../LPCUSB/usbstdreq.c ****  */
 104:../LPCUSB/usbstdreq.c **** BOOL USBGetDescriptor(U16 wTypeIndex, U16 wLangID, int *piLen, U8 **ppbData)
 105:../LPCUSB/usbstdreq.c **** {
  46              		.loc 1 105 0
  47              		.cfi_startproc
  48              		@ Function supports interworking.
  49              		@ args = 0, pretend = 0, frame = 0
  50              		@ frame_needed = 0, uses_anonymous_args = 0
  51              		@ link register save eliminated.
  52              	.LVL1:
 106:../LPCUSB/usbstdreq.c **** 	U8	bType, bIndex;
 107:../LPCUSB/usbstdreq.c **** 	U8	*pab;
 108:../LPCUSB/usbstdreq.c **** 	int iCurIndex;
 109:../LPCUSB/usbstdreq.c **** 	
 110:../LPCUSB/usbstdreq.c **** 	ASSERT(pabDescrip != NULL);
 111:../LPCUSB/usbstdreq.c **** 
 112:../LPCUSB/usbstdreq.c **** 	bType = GET_DESC_TYPE(wTypeIndex);
 113:../LPCUSB/usbstdreq.c **** 	bIndex = GET_DESC_INDEX(wTypeIndex);
 114:../LPCUSB/usbstdreq.c **** 	
 115:../LPCUSB/usbstdreq.c **** 	pab = (U8 *)pabDescrip;
  53              		.loc 1 115 0
  54 0010 68109FE5 		ldr	r1, .L12
  55              	.LVL2:
 105:../LPCUSB/usbstdreq.c **** {
  56              		.loc 1 105 0
  57 0014 70002DE9 		stmfd	sp!, {r4, r5, r6}
  58              	.LCFI0:
  59              		.cfi_def_cfa_offset 12
  60              		.cfi_offset 6, -4
  61              		.cfi_offset 5, -8
  62              		.cfi_offset 4, -12
  63              		.loc 1 115 0
  64 0018 001091E5 		ldr	r1, [r1, #0]
 112:../LPCUSB/usbstdreq.c **** 	bType = GET_DESC_TYPE(wTypeIndex);
  65              		.loc 1 112 0
  66 001c 2044A0E1 		mov	r4, r0, lsr #8
  67              	.LVL3:
 113:../LPCUSB/usbstdreq.c **** 	bIndex = GET_DESC_INDEX(wTypeIndex);
  68              		.loc 1 113 0
  69 0020 FF5000E2 		and	r5, r0, #255
  70              	.LVL4:
 116:../LPCUSB/usbstdreq.c **** 	iCurIndex = 0;
  71              		.loc 1 116 0
  72 0024 00C0A0E3 		mov	ip, #0
 117:../LPCUSB/usbstdreq.c **** 	
 118:../LPCUSB/usbstdreq.c **** 	while (pab[DESC_bLength] != 0) {
  73              		.loc 1 118 0
  74 0028 0F0000EA 		b	.L5
  75              	.LVL5:
  76              	.L10:
 119:../LPCUSB/usbstdreq.c **** 		if (pab[DESC_bDescriptorType] == bType) {
  77              		.loc 1 119 0
  78 002c 0160D1E5 		ldrb	r6, [r1, #1]	@ zero_extendqisi2
  79 0030 040056E1 		cmp	r6, r4
  80 0034 0B00001A 		bne	.L6
 120:../LPCUSB/usbstdreq.c **** 			if (iCurIndex == bIndex) {
  81              		.loc 1 120 0
  82 0038 05005CE1 		cmp	ip, r5
  83 003c 0800001A 		bne	.L7
 121:../LPCUSB/usbstdreq.c **** 				// set data pointer
 122:../LPCUSB/usbstdreq.c **** 				*ppbData = pab;
  84              		.loc 1 122 0
  85 0040 001083E5 		str	r1, [r3, #0]
 123:../LPCUSB/usbstdreq.c **** 				// get length from structure
 124:../LPCUSB/usbstdreq.c **** 				if (bType == DESC_CONFIGURATION) {
  86              		.loc 1 124 0
  87 0044 020054E3 		cmp	r4, #2
 125:../LPCUSB/usbstdreq.c **** 					// configuration descriptor is an exception, length is at offset 2 and 3
 126:../LPCUSB/usbstdreq.c **** 					*piLen =	(pab[CONF_DESC_wTotalLength]) |
 127:../LPCUSB/usbstdreq.c **** 								(pab[CONF_DESC_wTotalLength + 1] << 8);
  88              		.loc 1 127 0
  89 0048 0300D105 		ldreqb	r0, [r1, #3]	@ zero_extendqisi2
 126:../LPCUSB/usbstdreq.c **** 					*piLen =	(pab[CONF_DESC_wTotalLength]) |
  90              		.loc 1 126 0
  91 004c 0230D105 		ldreqb	r3, [r1, #2]	@ zero_extendqisi2
  92              	.LVL6:
 128:../LPCUSB/usbstdreq.c **** 				}
 129:../LPCUSB/usbstdreq.c **** 				else {
 130:../LPCUSB/usbstdreq.c **** 					// normally length is at offset 0
 131:../LPCUSB/usbstdreq.c **** 					*piLen = pab[DESC_bLength];
  93              		.loc 1 131 0
  94 0050 0030D115 		ldrneb	r3, [r1, #0]	@ zero_extendqisi2
 126:../LPCUSB/usbstdreq.c **** 					*piLen =	(pab[CONF_DESC_wTotalLength]) |
  95              		.loc 1 126 0
  96 0054 00348301 		orreq	r3, r3, r0, asl #8
  97              		.loc 1 131 0
  98 0058 003082E5 		str	r3, [r2, #0]
 132:../LPCUSB/usbstdreq.c **** 				}
 133:../LPCUSB/usbstdreq.c **** 				return TRUE;
  99              		.loc 1 133 0
 100 005c 0100A0E3 		mov	r0, #1
 101 0060 040000EA 		b	.L9
 102              	.LVL7:
 103              	.L7:
 134:../LPCUSB/usbstdreq.c **** 			}
 135:../LPCUSB/usbstdreq.c **** 			iCurIndex++;
 104              		.loc 1 135 0
 105 0064 01C08CE2 		add	ip, ip, #1
 106              	.LVL8:
 107              	.L6:
 136:../LPCUSB/usbstdreq.c **** 		}
 137:../LPCUSB/usbstdreq.c **** 		// skip to next descriptor
 138:../LPCUSB/usbstdreq.c **** 		pab += pab[DESC_bLength];
 108              		.loc 1 138 0
 109 0068 001081E0 		add	r1, r1, r0
 110              	.LVL9:
 111              	.L5:
 118:../LPCUSB/usbstdreq.c **** 	while (pab[DESC_bLength] != 0) {
 112              		.loc 1 118 0 discriminator 1
 113 006c 0000D1E5 		ldrb	r0, [r1, #0]	@ zero_extendqisi2
 114 0070 000050E3 		cmp	r0, #0
 115 0074 ECFFFF1A 		bne	.L10
 116              	.LVL10:
 117              	.L9:
 139:../LPCUSB/usbstdreq.c **** 	}
 140:../LPCUSB/usbstdreq.c **** 	// nothing found
 141:../LPCUSB/usbstdreq.c **** 	DBG("Desc %x not found!\n", wTypeIndex);
 142:../LPCUSB/usbstdreq.c **** 	return FALSE;
 143:../LPCUSB/usbstdreq.c **** }
 118              		.loc 1 143 0
 119 0078 7000BDE8 		ldmfd	sp!, {r4, r5, r6}
 120 007c 1EFF2FE1 		bx	lr
 121              	.L13:
 122              		.align	2
 123              	.L12:
 124 0080 00000000 		.word	.LANCHOR0
 125              		.cfi_endproc
 126              	.LFE1:
 128              		.align	2
 129              		.global	USBHandleStandardRequest
 131              	USBHandleStandardRequest:
 132              	.LFB6:
 144:../LPCUSB/usbstdreq.c **** 
 145:../LPCUSB/usbstdreq.c **** 
 146:../LPCUSB/usbstdreq.c **** /**
 147:../LPCUSB/usbstdreq.c **** 	Configures the device according to the specified configuration index and
 148:../LPCUSB/usbstdreq.c **** 	alternate setting by parsing the installed USB descriptor list.
 149:../LPCUSB/usbstdreq.c **** 	A configuration index of 0 unconfigures the device.
 150:../LPCUSB/usbstdreq.c **** 		
 151:../LPCUSB/usbstdreq.c **** 	@param [in]		bConfigIndex	Configuration index
 152:../LPCUSB/usbstdreq.c **** 	@param [in]		bAltSetting		Alternate setting number
 153:../LPCUSB/usbstdreq.c **** 	
 154:../LPCUSB/usbstdreq.c **** 	@todo function always returns TRUE, add stricter checking?
 155:../LPCUSB/usbstdreq.c **** 	
 156:../LPCUSB/usbstdreq.c **** 	@return TRUE if successfully configured, FALSE otherwise
 157:../LPCUSB/usbstdreq.c ****  */
 158:../LPCUSB/usbstdreq.c **** static BOOL USBSetConfiguration(U8 bConfigIndex, U8 bAltSetting)
 159:../LPCUSB/usbstdreq.c **** {
 160:../LPCUSB/usbstdreq.c **** 	U8	*pab;
 161:../LPCUSB/usbstdreq.c **** 	U8	bCurConfig, bCurAltSetting;
 162:../LPCUSB/usbstdreq.c **** 	U8	bEP;
 163:../LPCUSB/usbstdreq.c **** 	U16	wMaxPktSize;
 164:../LPCUSB/usbstdreq.c **** 	
 165:../LPCUSB/usbstdreq.c **** 	ASSERT(pabDescrip != NULL);
 166:../LPCUSB/usbstdreq.c **** 
 167:../LPCUSB/usbstdreq.c **** 	if (bConfigIndex == 0) {
 168:../LPCUSB/usbstdreq.c **** 		// unconfigure device
 169:../LPCUSB/usbstdreq.c **** 		USBHwConfigDevice(FALSE);
 170:../LPCUSB/usbstdreq.c **** 	}
 171:../LPCUSB/usbstdreq.c **** 	else {
 172:../LPCUSB/usbstdreq.c **** 		// configure endpoints for this configuration/altsetting
 173:../LPCUSB/usbstdreq.c **** 		pab = (U8 *)pabDescrip;
 174:../LPCUSB/usbstdreq.c **** 		bCurConfig = 0xFF;
 175:../LPCUSB/usbstdreq.c **** 		bCurAltSetting = 0xFF;
 176:../LPCUSB/usbstdreq.c **** 
 177:../LPCUSB/usbstdreq.c **** 		while (pab[DESC_bLength] != 0) {
 178:../LPCUSB/usbstdreq.c **** 
 179:../LPCUSB/usbstdreq.c **** 			switch (pab[DESC_bDescriptorType]) {
 180:../LPCUSB/usbstdreq.c **** 
 181:../LPCUSB/usbstdreq.c **** 			case DESC_CONFIGURATION:
 182:../LPCUSB/usbstdreq.c **** 				// remember current configuration index
 183:../LPCUSB/usbstdreq.c **** 				bCurConfig = pab[CONF_DESC_bConfigurationValue];
 184:../LPCUSB/usbstdreq.c **** 				break;
 185:../LPCUSB/usbstdreq.c **** 
 186:../LPCUSB/usbstdreq.c **** 			case DESC_INTERFACE:
 187:../LPCUSB/usbstdreq.c **** 				// remember current alternate setting
 188:../LPCUSB/usbstdreq.c **** 				bCurAltSetting = pab[INTF_DESC_bAlternateSetting];
 189:../LPCUSB/usbstdreq.c **** 				break;
 190:../LPCUSB/usbstdreq.c **** 
 191:../LPCUSB/usbstdreq.c **** 			case DESC_ENDPOINT:
 192:../LPCUSB/usbstdreq.c **** 				if ((bCurConfig == bConfigIndex) &&
 193:../LPCUSB/usbstdreq.c **** 					(bCurAltSetting == bAltSetting)) {
 194:../LPCUSB/usbstdreq.c **** 					// endpoint found for desired config and alternate setting
 195:../LPCUSB/usbstdreq.c **** 					bEP = pab[ENDP_DESC_bEndpointAddress];
 196:../LPCUSB/usbstdreq.c **** 					wMaxPktSize = 	(pab[ENDP_DESC_wMaxPacketSize]) |
 197:../LPCUSB/usbstdreq.c **** 									(pab[ENDP_DESC_wMaxPacketSize + 1] << 8);
 198:../LPCUSB/usbstdreq.c **** 					// configure endpoint
 199:../LPCUSB/usbstdreq.c **** 					USBHwEPConfig(bEP, wMaxPktSize);
 200:../LPCUSB/usbstdreq.c **** 				}
 201:../LPCUSB/usbstdreq.c **** 				break;
 202:../LPCUSB/usbstdreq.c **** 
 203:../LPCUSB/usbstdreq.c **** 			default:
 204:../LPCUSB/usbstdreq.c **** 				break;
 205:../LPCUSB/usbstdreq.c **** 			}
 206:../LPCUSB/usbstdreq.c **** 			// skip to next descriptor
 207:../LPCUSB/usbstdreq.c **** 			pab += pab[DESC_bLength];
 208:../LPCUSB/usbstdreq.c **** 		}
 209:../LPCUSB/usbstdreq.c **** 		
 210:../LPCUSB/usbstdreq.c **** 		// configure device
 211:../LPCUSB/usbstdreq.c **** 		USBHwConfigDevice(TRUE);
 212:../LPCUSB/usbstdreq.c **** 	}
 213:../LPCUSB/usbstdreq.c **** 
 214:../LPCUSB/usbstdreq.c **** 	return TRUE;
 215:../LPCUSB/usbstdreq.c **** }
 216:../LPCUSB/usbstdreq.c **** 
 217:../LPCUSB/usbstdreq.c **** 
 218:../LPCUSB/usbstdreq.c **** /**
 219:../LPCUSB/usbstdreq.c **** 	Local function to handle a standard device request
 220:../LPCUSB/usbstdreq.c **** 		
 221:../LPCUSB/usbstdreq.c **** 	@param [in]		pSetup		The setup packet
 222:../LPCUSB/usbstdreq.c **** 	@param [in,out]	*piLen		Pointer to data length
 223:../LPCUSB/usbstdreq.c **** 	@param [in,out]	ppbData		Data buffer.
 224:../LPCUSB/usbstdreq.c **** 
 225:../LPCUSB/usbstdreq.c **** 	@return TRUE if the request was handled successfully
 226:../LPCUSB/usbstdreq.c ****  */
 227:../LPCUSB/usbstdreq.c **** static BOOL HandleStdDeviceReq(TSetupPacket *pSetup, int *piLen, U8 **ppbData)
 228:../LPCUSB/usbstdreq.c **** {
 229:../LPCUSB/usbstdreq.c **** 	U8	*pbData = *ppbData;
 230:../LPCUSB/usbstdreq.c **** 
 231:../LPCUSB/usbstdreq.c **** 	switch (pSetup->bRequest) {
 232:../LPCUSB/usbstdreq.c **** 	
 233:../LPCUSB/usbstdreq.c **** 	case REQ_GET_STATUS:
 234:../LPCUSB/usbstdreq.c **** 		// bit 0: self-powered
 235:../LPCUSB/usbstdreq.c **** 		// bit 1: remote wakeup = not supported
 236:../LPCUSB/usbstdreq.c **** 		pbData[0] = 0;
 237:../LPCUSB/usbstdreq.c **** 		pbData[1] = 0;
 238:../LPCUSB/usbstdreq.c **** 		*piLen = 2;
 239:../LPCUSB/usbstdreq.c **** 		break;
 240:../LPCUSB/usbstdreq.c **** 		
 241:../LPCUSB/usbstdreq.c **** 	case REQ_SET_ADDRESS:
 242:../LPCUSB/usbstdreq.c **** 		USBHwSetAddress(pSetup->wValue);
 243:../LPCUSB/usbstdreq.c **** 		break;
 244:../LPCUSB/usbstdreq.c **** 
 245:../LPCUSB/usbstdreq.c **** 	case REQ_GET_DESCRIPTOR:
 246:../LPCUSB/usbstdreq.c **** 		DBG("D%x", pSetup->wValue);
 247:../LPCUSB/usbstdreq.c **** 		return USBGetDescriptor(pSetup->wValue, pSetup->wIndex, piLen, ppbData);
 248:../LPCUSB/usbstdreq.c **** 
 249:../LPCUSB/usbstdreq.c **** 	case REQ_GET_CONFIGURATION:
 250:../LPCUSB/usbstdreq.c **** 		// indicate if we are configured
 251:../LPCUSB/usbstdreq.c **** 		pbData[0] = bConfiguration;
 252:../LPCUSB/usbstdreq.c **** 		*piLen = 1;
 253:../LPCUSB/usbstdreq.c **** 		break;
 254:../LPCUSB/usbstdreq.c **** 
 255:../LPCUSB/usbstdreq.c **** 	case REQ_SET_CONFIGURATION:
 256:../LPCUSB/usbstdreq.c **** 		if (!USBSetConfiguration(pSetup->wValue & 0xFF, 0)) {
 257:../LPCUSB/usbstdreq.c **** 			DBG("USBSetConfiguration failed!\n");
 258:../LPCUSB/usbstdreq.c **** 			return FALSE;
 259:../LPCUSB/usbstdreq.c **** 		}
 260:../LPCUSB/usbstdreq.c **** 		// configuration successful, update current configuration
 261:../LPCUSB/usbstdreq.c **** 		bConfiguration = pSetup->wValue & 0xFF;	
 262:../LPCUSB/usbstdreq.c **** 		break;
 263:../LPCUSB/usbstdreq.c **** 
 264:../LPCUSB/usbstdreq.c **** 	case REQ_CLEAR_FEATURE:
 265:../LPCUSB/usbstdreq.c **** 	case REQ_SET_FEATURE:
 266:../LPCUSB/usbstdreq.c **** 		if (pSetup->wValue == FEA_REMOTE_WAKEUP) {
 267:../LPCUSB/usbstdreq.c **** 			// put DEVICE_REMOTE_WAKEUP code here
 268:../LPCUSB/usbstdreq.c **** 		}
 269:../LPCUSB/usbstdreq.c **** 		if (pSetup->wValue == FEA_TEST_MODE) {
 270:../LPCUSB/usbstdreq.c **** 			// put TEST_MODE code here
 271:../LPCUSB/usbstdreq.c **** 		}
 272:../LPCUSB/usbstdreq.c **** 		return FALSE;
 273:../LPCUSB/usbstdreq.c **** 
 274:../LPCUSB/usbstdreq.c **** 	case REQ_SET_DESCRIPTOR:
 275:../LPCUSB/usbstdreq.c **** 		DBG("Device req %d not implemented\n", pSetup->bRequest);
 276:../LPCUSB/usbstdreq.c **** 		return FALSE;
 277:../LPCUSB/usbstdreq.c **** 
 278:../LPCUSB/usbstdreq.c **** 	default:
 279:../LPCUSB/usbstdreq.c **** 		DBG("Illegal device req %d\n", pSetup->bRequest);
 280:../LPCUSB/usbstdreq.c **** 		return FALSE;
 281:../LPCUSB/usbstdreq.c **** 	}
 282:../LPCUSB/usbstdreq.c **** 	
 283:../LPCUSB/usbstdreq.c **** 	return TRUE;
 284:../LPCUSB/usbstdreq.c **** }
 285:../LPCUSB/usbstdreq.c **** 
 286:../LPCUSB/usbstdreq.c **** 
 287:../LPCUSB/usbstdreq.c **** /**
 288:../LPCUSB/usbstdreq.c **** 	Local function to handle a standard interface request
 289:../LPCUSB/usbstdreq.c **** 		
 290:../LPCUSB/usbstdreq.c **** 	@param [in]		pSetup		The setup packet
 291:../LPCUSB/usbstdreq.c **** 	@param [in,out]	*piLen		Pointer to data length
 292:../LPCUSB/usbstdreq.c **** 	@param [in]		ppbData		Data buffer.
 293:../LPCUSB/usbstdreq.c **** 
 294:../LPCUSB/usbstdreq.c **** 	@return TRUE if the request was handled successfully
 295:../LPCUSB/usbstdreq.c ****  */
 296:../LPCUSB/usbstdreq.c **** static BOOL HandleStdInterfaceReq(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
 297:../LPCUSB/usbstdreq.c **** {
 298:../LPCUSB/usbstdreq.c **** 	U8	*pbData = *ppbData;
 299:../LPCUSB/usbstdreq.c **** 
 300:../LPCUSB/usbstdreq.c **** 	switch (pSetup->bRequest) {
 301:../LPCUSB/usbstdreq.c **** 
 302:../LPCUSB/usbstdreq.c **** 	case REQ_GET_STATUS:
 303:../LPCUSB/usbstdreq.c **** 		// no bits specified
 304:../LPCUSB/usbstdreq.c **** 		pbData[0] = 0;
 305:../LPCUSB/usbstdreq.c **** 		pbData[1] = 0;
 306:../LPCUSB/usbstdreq.c **** 		*piLen = 2;
 307:../LPCUSB/usbstdreq.c **** 		break;
 308:../LPCUSB/usbstdreq.c **** 
 309:../LPCUSB/usbstdreq.c **** 	case REQ_CLEAR_FEATURE:
 310:../LPCUSB/usbstdreq.c **** 	case REQ_SET_FEATURE:
 311:../LPCUSB/usbstdreq.c **** 		// not defined for interface
 312:../LPCUSB/usbstdreq.c **** 		return FALSE;
 313:../LPCUSB/usbstdreq.c **** 	
 314:../LPCUSB/usbstdreq.c **** 	case REQ_GET_INTERFACE:	// TODO use bNumInterfaces
 315:../LPCUSB/usbstdreq.c ****         // there is only one interface, return n-1 (= 0)
 316:../LPCUSB/usbstdreq.c **** 		pbData[0] = 0;
 317:../LPCUSB/usbstdreq.c **** 		*piLen = 1;
 318:../LPCUSB/usbstdreq.c **** 		break;
 319:../LPCUSB/usbstdreq.c **** 	
 320:../LPCUSB/usbstdreq.c **** 	case REQ_SET_INTERFACE:	// TODO use bNumInterfaces
 321:../LPCUSB/usbstdreq.c **** 		// there is only one interface (= 0)
 322:../LPCUSB/usbstdreq.c **** 		if (pSetup->wValue != 0) {
 323:../LPCUSB/usbstdreq.c **** 			return FALSE;
 324:../LPCUSB/usbstdreq.c **** 		}
 325:../LPCUSB/usbstdreq.c **** 		*piLen = 0;
 326:../LPCUSB/usbstdreq.c **** 		break;
 327:../LPCUSB/usbstdreq.c **** 
 328:../LPCUSB/usbstdreq.c **** 	default:
 329:../LPCUSB/usbstdreq.c **** 		DBG("Illegal interface req %d\n", pSetup->bRequest);
 330:../LPCUSB/usbstdreq.c **** 		return FALSE;
 331:../LPCUSB/usbstdreq.c **** 	}
 332:../LPCUSB/usbstdreq.c **** 
 333:../LPCUSB/usbstdreq.c **** 	return TRUE;
 334:../LPCUSB/usbstdreq.c **** }
 335:../LPCUSB/usbstdreq.c **** 
 336:../LPCUSB/usbstdreq.c **** 
 337:../LPCUSB/usbstdreq.c **** /**
 338:../LPCUSB/usbstdreq.c **** 	Local function to handle a standard endpoint request
 339:../LPCUSB/usbstdreq.c **** 		
 340:../LPCUSB/usbstdreq.c **** 	@param [in]		pSetup		The setup packet
 341:../LPCUSB/usbstdreq.c **** 	@param [in,out]	*piLen		Pointer to data length
 342:../LPCUSB/usbstdreq.c **** 	@param [in]		ppbData		Data buffer.
 343:../LPCUSB/usbstdreq.c **** 
 344:../LPCUSB/usbstdreq.c **** 	@return TRUE if the request was handled successfully
 345:../LPCUSB/usbstdreq.c ****  */
 346:../LPCUSB/usbstdreq.c **** static BOOL HandleStdEndPointReq(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
 347:../LPCUSB/usbstdreq.c **** {
 348:../LPCUSB/usbstdreq.c **** 	U8	*pbData = *ppbData;
 349:../LPCUSB/usbstdreq.c **** 
 350:../LPCUSB/usbstdreq.c **** 	switch (pSetup->bRequest) {
 351:../LPCUSB/usbstdreq.c **** 	case REQ_GET_STATUS:
 352:../LPCUSB/usbstdreq.c **** 		// bit 0 = endpointed halted or not
 353:../LPCUSB/usbstdreq.c **** 		pbData[0] = (USBHwEPGetStatus(pSetup->wIndex) & EP_STATUS_STALLED) ? 1 : 0;
 354:../LPCUSB/usbstdreq.c **** 		pbData[1] = 0;
 355:../LPCUSB/usbstdreq.c **** 		*piLen = 2;
 356:../LPCUSB/usbstdreq.c **** 		break;
 357:../LPCUSB/usbstdreq.c **** 		
 358:../LPCUSB/usbstdreq.c **** 	case REQ_CLEAR_FEATURE:
 359:../LPCUSB/usbstdreq.c **** 		if (pSetup->wValue == FEA_ENDPOINT_HALT) {
 360:../LPCUSB/usbstdreq.c **** 			// clear HALT by unstalling
 361:../LPCUSB/usbstdreq.c **** 			USBHwEPStall(pSetup->wIndex, FALSE);
 362:../LPCUSB/usbstdreq.c **** 			break;
 363:../LPCUSB/usbstdreq.c **** 		}
 364:../LPCUSB/usbstdreq.c **** 		// only ENDPOINT_HALT defined for endpoints
 365:../LPCUSB/usbstdreq.c **** 		return FALSE;
 366:../LPCUSB/usbstdreq.c **** 	
 367:../LPCUSB/usbstdreq.c **** 	case REQ_SET_FEATURE:
 368:../LPCUSB/usbstdreq.c **** 		if (pSetup->wValue == FEA_ENDPOINT_HALT) {
 369:../LPCUSB/usbstdreq.c **** 			// set HALT by stalling
 370:../LPCUSB/usbstdreq.c **** 			USBHwEPStall(pSetup->wIndex, TRUE);
 371:../LPCUSB/usbstdreq.c **** 			break;
 372:../LPCUSB/usbstdreq.c **** 		}
 373:../LPCUSB/usbstdreq.c **** 		// only ENDPOINT_HALT defined for endpoints
 374:../LPCUSB/usbstdreq.c **** 		return FALSE;
 375:../LPCUSB/usbstdreq.c **** 
 376:../LPCUSB/usbstdreq.c **** 	case REQ_SYNCH_FRAME:
 377:../LPCUSB/usbstdreq.c **** 		DBG("EP req %d not implemented\n", pSetup->bRequest);
 378:../LPCUSB/usbstdreq.c **** 		return FALSE;
 379:../LPCUSB/usbstdreq.c **** 
 380:../LPCUSB/usbstdreq.c **** 	default:
 381:../LPCUSB/usbstdreq.c **** 		DBG("Illegal EP req %d\n", pSetup->bRequest);
 382:../LPCUSB/usbstdreq.c **** 		return FALSE;
 383:../LPCUSB/usbstdreq.c **** 	}
 384:../LPCUSB/usbstdreq.c **** 	
 385:../LPCUSB/usbstdreq.c **** 	return TRUE;
 386:../LPCUSB/usbstdreq.c **** }
 387:../LPCUSB/usbstdreq.c **** 
 388:../LPCUSB/usbstdreq.c **** 
 389:../LPCUSB/usbstdreq.c **** /**
 390:../LPCUSB/usbstdreq.c **** 	Default handler for standard ('chapter 9') requests
 391:../LPCUSB/usbstdreq.c **** 	
 392:../LPCUSB/usbstdreq.c **** 	If a custom request handler was installed, this handler is called first.
 393:../LPCUSB/usbstdreq.c **** 		
 394:../LPCUSB/usbstdreq.c **** 	@param [in]		pSetup		The setup packet
 395:../LPCUSB/usbstdreq.c **** 	@param [in,out]	*piLen		Pointer to data length
 396:../LPCUSB/usbstdreq.c **** 	@param [in]		ppbData		Data buffer.
 397:../LPCUSB/usbstdreq.c **** 
 398:../LPCUSB/usbstdreq.c **** 	@return TRUE if the request was handled successfully
 399:../LPCUSB/usbstdreq.c ****  */
 400:../LPCUSB/usbstdreq.c **** BOOL USBHandleStandardRequest(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
 401:../LPCUSB/usbstdreq.c **** {
 133              		.loc 1 401 0
 134              		.cfi_startproc
 135              		@ Function supports interworking.
 136              		@ args = 0, pretend = 0, frame = 0
 137              		@ frame_needed = 0, uses_anonymous_args = 0
 138              	.LVL11:
 402:../LPCUSB/usbstdreq.c **** 	// try the custom request handler first
 403:../LPCUSB/usbstdreq.c **** 	if ((pfnHandleCustomReq != NULL) && pfnHandleCustomReq(pSetup, piLen, ppbData)) {
 139              		.loc 1 403 0
 140 0084 54329FE5 		ldr	r3, .L58
 141 0088 043093E5 		ldr	r3, [r3, #4]
 142 008c 000053E3 		cmp	r3, #0
 401:../LPCUSB/usbstdreq.c **** {
 143              		.loc 1 401 0
 144 0090 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 145              	.LCFI1:
 146              		.cfi_def_cfa_offset 24
 147              		.cfi_offset 14, -4
 148              		.cfi_offset 8, -8
 149              		.cfi_offset 7, -12
 150              		.cfi_offset 6, -16
 151              		.cfi_offset 5, -20
 152              		.cfi_offset 4, -24
 401:../LPCUSB/usbstdreq.c **** {
 153              		.loc 1 401 0
 154 0094 0040A0E1 		mov	r4, r0
 155 0098 0150A0E1 		mov	r5, r1
 156 009c 0260A0E1 		mov	r6, r2
 157              		.loc 1 403 0
 158 00a0 0300000A 		beq	.L15
 159              		.loc 1 403 0 is_stmt 0 discriminator 1
 160 00a4 0FE0A0E1 		mov	lr, pc
 161 00a8 13FF2FE1 		bx	r3
 162              	.LVL12:
 163 00ac 000050E3 		cmp	r0, #0
 164 00b0 8400001A 		bne	.L53
 165              	.L15:
 404:../LPCUSB/usbstdreq.c **** 		return TRUE;
 405:../LPCUSB/usbstdreq.c **** 	}
 406:../LPCUSB/usbstdreq.c **** 	
 407:../LPCUSB/usbstdreq.c **** 	switch (REQTYPE_GET_RECIP(pSetup->bmRequestType)) {
 166              		.loc 1 407 0 is_stmt 1
 167 00b4 0070D4E5 		ldrb	r7, [r4, #0]	@ zero_extendqisi2
 168 00b8 1F7007E2 		and	r7, r7, #31
 169 00bc 010057E3 		cmp	r7, #1
 170 00c0 4C00000A 		beq	.L18
 171 00c4 020057E3 		cmp	r7, #2
 172 00c8 5F00000A 		beq	.L19
 173 00cc 000057E3 		cmp	r7, #0
 174 00d0 7E00001A 		bne	.L48
 175              	.LVL13:
 176              	.LBB16:
 177              	.LBB17:
 231:../LPCUSB/usbstdreq.c **** 	switch (pSetup->bRequest) {
 178              		.loc 1 231 0
 179 00d4 0120D4E5 		ldrb	r2, [r4, #1]	@ zero_extendqisi2
 229:../LPCUSB/usbstdreq.c **** 	U8	*pbData = *ppbData;
 180              		.loc 1 229 0
 181 00d8 003096E5 		ldr	r3, [r6, #0]
 182              	.LVL14:
 231:../LPCUSB/usbstdreq.c **** 	switch (pSetup->bRequest) {
 183              		.loc 1 231 0
 184 00dc 090052E3 		cmp	r2, #9
 185 00e0 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 186 00e4 790000EA 		b	.L48
 187              	.L26:
 188 00e8 10010000 		.word	.L21
 189 00ec D0020000 		.word	.L48
 190 00f0 D0020000 		.word	.L48
 191 00f4 D0020000 		.word	.L48
 192 00f8 D0020000 		.word	.L48
 193 00fc 28010000 		.word	.L22
 194 0100 34010000 		.word	.L23
 195 0104 D0020000 		.word	.L48
 196 0108 4C010000 		.word	.L24
 197 010c 60010000 		.word	.L25
 198              	.L21:
 236:../LPCUSB/usbstdreq.c **** 		pbData[0] = 0;
 199              		.loc 1 236 0
 200 0110 0020A0E3 		mov	r2, #0
 201 0114 0020C3E5 		strb	r2, [r3, #0]
 237:../LPCUSB/usbstdreq.c **** 		pbData[1] = 0;
 202              		.loc 1 237 0
 203 0118 0120C3E5 		strb	r2, [r3, #1]
 238:../LPCUSB/usbstdreq.c **** 		*piLen = 2;
 204              		.loc 1 238 0
 205 011c 0230A0E3 		mov	r3, #2
 206 0120 003085E5 		str	r3, [r5, #0]
 207 0124 670000EA 		b	.L53
 208              	.L22:
 242:../LPCUSB/usbstdreq.c **** 		USBHwSetAddress(pSetup->wValue);
 209              		.loc 1 242 0
 210 0128 0200D4E5 		ldrb	r0, [r4, #2]	@ zero_extendqisi2
 211 012c FEFFFFEB 		bl	USBHwSetAddress
 212              	.LVL15:
 213 0130 640000EA 		b	.L53
 214              	.LVL16:
 215              	.L23:
 247:../LPCUSB/usbstdreq.c **** 		return USBGetDescriptor(pSetup->wValue, pSetup->wIndex, piLen, ppbData);
 216              		.loc 1 247 0
 217 0134 B200D4E1 		ldrh	r0, [r4, #2]
 218 0138 B410D4E1 		ldrh	r1, [r4, #4]
 219 013c 0520A0E1 		mov	r2, r5
 220 0140 0630A0E1 		mov	r3, r6
 221              	.LVL17:
 222              	.LBE17:
 223              	.LBE16:
 408:../LPCUSB/usbstdreq.c **** 	case REQTYPE_RECIP_DEVICE:		return HandleStdDeviceReq(pSetup, piLen, ppbData);
 409:../LPCUSB/usbstdreq.c **** 	case REQTYPE_RECIP_INTERFACE:	return HandleStdInterfaceReq(pSetup, piLen, ppbData);
 410:../LPCUSB/usbstdreq.c **** 	case REQTYPE_RECIP_ENDPOINT: 	return HandleStdEndPointReq(pSetup, piLen, ppbData);
 411:../LPCUSB/usbstdreq.c **** 	default: 						return FALSE;
 412:../LPCUSB/usbstdreq.c **** 	}
 413:../LPCUSB/usbstdreq.c **** }
 224              		.loc 1 413 0
 225 0144 F041BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, lr}
 226              	.LBB21:
 227              	.LBB20:
 247:../LPCUSB/usbstdreq.c **** 		return USBGetDescriptor(pSetup->wValue, pSetup->wIndex, piLen, ppbData);
 228              		.loc 1 247 0
 229 0148 FEFFFFEA 		b	USBGetDescriptor
 230              	.LVL18:
 231              	.L24:
 251:../LPCUSB/usbstdreq.c **** 		pbData[0] = bConfiguration;
 232              		.loc 1 251 0
 233 014c 8C219FE5 		ldr	r2, .L58
 234 0150 0820D2E5 		ldrb	r2, [r2, #8]	@ zero_extendqisi2
 252:../LPCUSB/usbstdreq.c **** 		*piLen = 1;
 235              		.loc 1 252 0
 236 0154 0170A0E3 		mov	r7, #1
 251:../LPCUSB/usbstdreq.c **** 		pbData[0] = bConfiguration;
 237              		.loc 1 251 0
 238 0158 0020C3E5 		strb	r2, [r3, #0]
 239 015c 330000EA 		b	.L54
 240              	.L25:
 256:../LPCUSB/usbstdreq.c **** 		if (!USBSetConfiguration(pSetup->wValue & 0xFF, 0)) {
 241              		.loc 1 256 0
 242 0160 0260D4E5 		ldrb	r6, [r4, #2]	@ zero_extendqisi2
 243              	.LVL19:
 244              	.LBB18:
 245              	.LBB19:
 167:../LPCUSB/usbstdreq.c **** 	if (bConfigIndex == 0) {
 246              		.loc 1 167 0
 247 0164 000056E3 		cmp	r6, #0
 169:../LPCUSB/usbstdreq.c **** 		USBHwConfigDevice(FALSE);
 248              		.loc 1 169 0
 249 0168 0600A001 		moveq	r0, r6
 167:../LPCUSB/usbstdreq.c **** 	if (bConfigIndex == 0) {
 250              		.loc 1 167 0
 251 016c 1C00000A 		beq	.L52
 173:../LPCUSB/usbstdreq.c **** 		pab = (U8 *)pabDescrip;
 252              		.loc 1 173 0
 253 0170 68319FE5 		ldr	r3, .L58
 254              	.LVL20:
 255 0174 005093E5 		ldr	r5, [r3, #0]
 256              	.LVL21:
 175:../LPCUSB/usbstdreq.c **** 		bCurAltSetting = 0xFF;
 257              		.loc 1 175 0
 258 0178 FF30A0E3 		mov	r3, #255
 174:../LPCUSB/usbstdreq.c **** 		bCurConfig = 0xFF;
 259              		.loc 1 174 0
 260 017c 0370A0E1 		mov	r7, r3
 261 0180 130000EA 		b	.L29
 262              	.LVL22:
 263              	.L34:
 179:../LPCUSB/usbstdreq.c **** 			switch (pab[DESC_bDescriptorType]) {
 264              		.loc 1 179 0
 265 0184 0120D5E5 		ldrb	r2, [r5, #1]	@ zero_extendqisi2
 266 0188 040052E3 		cmp	r2, #4
 188:../LPCUSB/usbstdreq.c **** 				bCurAltSetting = pab[INTF_DESC_bAlternateSetting];
 267              		.loc 1 188 0
 268 018c 0330D505 		ldreqb	r3, [r5, #3]	@ zero_extendqisi2
 269              	.LVL23:
 179:../LPCUSB/usbstdreq.c **** 			switch (pab[DESC_bDescriptorType]) {
 270              		.loc 1 179 0
 271 0190 0D00000A 		beq	.L30
 272 0194 050052E3 		cmp	r2, #5
 273 0198 0200000A 		beq	.L33
 274 019c 020052E3 		cmp	r2, #2
 183:../LPCUSB/usbstdreq.c **** 				bCurConfig = pab[CONF_DESC_bConfigurationValue];
 275              		.loc 1 183 0
 276 01a0 0570D505 		ldreqb	r7, [r5, #5]	@ zero_extendqisi2
 277              	.LVL24:
 278 01a4 080000EA 		b	.L30
 279              	.LVL25:
 280              	.L33:
 192:../LPCUSB/usbstdreq.c **** 				if ((bCurConfig == bConfigIndex) &&
 281              		.loc 1 192 0
 282 01a8 000053E3 		cmp	r3, #0
 283 01ac 06005701 		cmpeq	r7, r6
 284 01b0 0500001A 		bne	.L30
 285              	.LVL26:
 196:../LPCUSB/usbstdreq.c **** 					wMaxPktSize = 	(pab[ENDP_DESC_wMaxPacketSize]) |
 286              		.loc 1 196 0
 287 01b4 0430D5E5 		ldrb	r3, [r5, #4]	@ zero_extendqisi2
 197:../LPCUSB/usbstdreq.c **** 									(pab[ENDP_DESC_wMaxPacketSize + 1] << 8);
 288              		.loc 1 197 0
 289 01b8 0510D5E5 		ldrb	r1, [r5, #5]	@ zero_extendqisi2
 199:../LPCUSB/usbstdreq.c **** 					USBHwEPConfig(bEP, wMaxPktSize);
 290              		.loc 1 199 0
 291 01bc 0200D5E5 		ldrb	r0, [r5, #2]	@ zero_extendqisi2
 292 01c0 011483E1 		orr	r1, r3, r1, asl #8
 293 01c4 FEFFFFEB 		bl	USBHwEPConfig
 294              	.LVL27:
 295 01c8 0030A0E3 		mov	r3, #0
 296              	.LVL28:
 297              	.L30:
 207:../LPCUSB/usbstdreq.c **** 			pab += pab[DESC_bLength];
 298              		.loc 1 207 0
 299 01cc 0020D5E5 		ldrb	r2, [r5, #0]	@ zero_extendqisi2
 300 01d0 025085E0 		add	r5, r5, r2
 301              	.LVL29:
 302              	.L29:
 177:../LPCUSB/usbstdreq.c **** 		while (pab[DESC_bLength] != 0) {
 303              		.loc 1 177 0
 304 01d4 0020D5E5 		ldrb	r2, [r5, #0]	@ zero_extendqisi2
 305 01d8 000052E3 		cmp	r2, #0
 306 01dc E8FFFF1A 		bne	.L34
 211:../LPCUSB/usbstdreq.c **** 		USBHwConfigDevice(TRUE);
 307              		.loc 1 211 0
 308 01e0 0100A0E3 		mov	r0, #1
 309              	.LVL30:
 310              	.L52:
 311 01e4 FEFFFFEB 		bl	USBHwConfigDevice
 312              	.LBE19:
 313              	.LBE18:
 261:../LPCUSB/usbstdreq.c **** 		bConfiguration = pSetup->wValue & 0xFF;	
 314              		.loc 1 261 0
 315 01e8 B220D4E1 		ldrh	r2, [r4, #2]
 316 01ec EC309FE5 		ldr	r3, .L58
 317 01f0 0820C3E5 		strb	r2, [r3, #8]
 318 01f4 330000EA 		b	.L53
 319              	.LVL31:
 320              	.L18:
 321              	.LBE20:
 322              	.LBE21:
 323              	.LBB22:
 324              	.LBB23:
 300:../LPCUSB/usbstdreq.c **** 	switch (pSetup->bRequest) {
 325              		.loc 1 300 0
 326 01f8 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 327              	.LBE23:
 328              	.LBE22:
 414:../LPCUSB/usbstdreq.c **** 
 415:../LPCUSB/usbstdreq.c **** 
 416:../LPCUSB/usbstdreq.c **** /**
 417:../LPCUSB/usbstdreq.c **** 	Registers a callback for custom device requests
 418:../LPCUSB/usbstdreq.c **** 	
 419:../LPCUSB/usbstdreq.c **** 	In USBHandleStandardRequest, the custom request handler gets a first
 420:../LPCUSB/usbstdreq.c **** 	chance at handling the request before it is handed over to the 'chapter 9'
 421:../LPCUSB/usbstdreq.c **** 	request handler.
 422:../LPCUSB/usbstdreq.c **** 	
 423:../LPCUSB/usbstdreq.c **** 	This can be used for example in HID devices, where a REQ_GET_DESCRIPTOR
 424:../LPCUSB/usbstdreq.c **** 	request is sent to an interface, which is not covered by the 'chapter 9'
 425:../LPCUSB/usbstdreq.c **** 	specification.
 426:../LPCUSB/usbstdreq.c **** 		
 427:../LPCUSB/usbstdreq.c **** 	@param [in]	pfnHandler	Callback function pointer
 428:../LPCUSB/usbstdreq.c ****  */
 429:../LPCUSB/usbstdreq.c **** void USBRegisterCustomReqHandler(TFnHandleRequest *pfnHandler)
 430:../LPCUSB/usbstdreq.c **** {
 431:../LPCUSB/usbstdreq.c **** 	pfnHandleCustomReq = pfnHandler;
 432:../LPCUSB/usbstdreq.c **** }
 329              		.loc 1 432 0
 330 01fc 002096E5 		ldr	r2, [r6, #0]
 331              	.LVL32:
 332              	.LBB25:
 333              	.LBB24:
 300:../LPCUSB/usbstdreq.c **** 	switch (pSetup->bRequest) {
 334              		.loc 1 300 0
 335 0200 000053E3 		cmp	r3, #0
 304:../LPCUSB/usbstdreq.c **** 		pbData[0] = 0;
 336              		.loc 1 304 0
 337 0204 0030C205 		streqb	r3, [r2, #0]
 305:../LPCUSB/usbstdreq.c **** 		pbData[1] = 0;
 338              		.loc 1 305 0
 339 0208 0130C205 		streqb	r3, [r2, #1]
 306:../LPCUSB/usbstdreq.c **** 		*piLen = 2;
 340              		.loc 1 306 0
 341 020c 0230A003 		moveq	r3, #2
 300:../LPCUSB/usbstdreq.c **** 	switch (pSetup->bRequest) {
 342              		.loc 1 300 0
 343 0210 0B00000A 		beq	.L55
 344 0214 0A0053E3 		cmp	r3, #10
 345 0218 0200000A 		beq	.L36
 346 021c 0B0053E3 		cmp	r3, #11
 347 0220 2A00001A 		bne	.L48
 348 0224 030000EA 		b	.L56
 349              	.L36:
 316:../LPCUSB/usbstdreq.c **** 		pbData[0] = 0;
 350              		.loc 1 316 0
 351 0228 0030A0E3 		mov	r3, #0
 352 022c 0030C2E5 		strb	r3, [r2, #0]
 353              	.LVL33:
 354              	.L54:
 317:../LPCUSB/usbstdreq.c **** 		*piLen = 1;
 355              		.loc 1 317 0
 356 0230 007085E5 		str	r7, [r5, #0]
 357 0234 260000EA 		b	.L16
 358              	.LVL34:
 359              	.L56:
 322:../LPCUSB/usbstdreq.c **** 		if (pSetup->wValue != 0) {
 360              		.loc 1 322 0
 361 0238 B230D4E1 		ldrh	r3, [r4, #2]
 362 023c 000053E3 		cmp	r3, #0
 363 0240 2200001A 		bne	.L48
 364              	.L55:
 325:../LPCUSB/usbstdreq.c **** 		*piLen = 0;
 365              		.loc 1 325 0
 366 0244 003085E5 		str	r3, [r5, #0]
 367 0248 210000EA 		b	.L16
 368              	.LVL35:
 369              	.L19:
 370              		.loc 1 432 0
 371 024c 008096E5 		ldr	r8, [r6, #0]
 372              	.LVL36:
 373              	.LBE24:
 374              	.LBE25:
 375              	.LBB26:
 376              	.LBB27:
 350:../LPCUSB/usbstdreq.c **** 	switch (pSetup->bRequest) {
 377              		.loc 1 350 0
 378 0250 0160D4E5 		ldrb	r6, [r4, #1]	@ zero_extendqisi2
 379              	.LVL37:
 380 0254 010056E3 		cmp	r6, #1
 381 0258 0D00000A 		beq	.L39
 382 025c 0200003A 		bcc	.L38
 383 0260 030056E3 		cmp	r6, #3
 384 0264 1900001A 		bne	.L48
 385 0268 100000EA 		b	.L57
 386              	.L38:
 353:../LPCUSB/usbstdreq.c **** 		pbData[0] = (USBHwEPGetStatus(pSetup->wIndex) & EP_STATUS_STALLED) ? 1 : 0;
 387              		.loc 1 353 0
 388 026c 0400D4E5 		ldrb	r0, [r4, #4]	@ zero_extendqisi2
 389 0270 FEFFFFEB 		bl	USBHwEPGetStatus
 390 0274 020010E3 		tst	r0, #2
 391 0278 0030A003 		moveq	r3, #0
 392 027c 0130A013 		movne	r3, #1
 393 0280 0030C8E5 		strb	r3, [r8, #0]
 354:../LPCUSB/usbstdreq.c **** 		pbData[1] = 0;
 394              		.loc 1 354 0
 395 0284 0030A0E3 		mov	r3, #0
 396 0288 0130C8E5 		strb	r3, [r8, #1]
 355:../LPCUSB/usbstdreq.c **** 		*piLen = 2;
 397              		.loc 1 355 0
 398 028c 007085E5 		str	r7, [r5, #0]
 399 0290 0C0000EA 		b	.L53
 400              	.L39:
 359:../LPCUSB/usbstdreq.c **** 		if (pSetup->wValue == FEA_ENDPOINT_HALT) {
 401              		.loc 1 359 0
 402 0294 B210D4E1 		ldrh	r1, [r4, #2]
 403 0298 000051E3 		cmp	r1, #0
 404 029c 0B00001A 		bne	.L48
 361:../LPCUSB/usbstdreq.c **** 			USBHwEPStall(pSetup->wIndex, FALSE);
 405              		.loc 1 361 0
 406 02a0 0400D4E5 		ldrb	r0, [r4, #4]	@ zero_extendqisi2
 407 02a4 FEFFFFEB 		bl	USBHwEPStall
 385:../LPCUSB/usbstdreq.c **** 	return TRUE;
 408              		.loc 1 385 0
 409 02a8 0670A0E1 		mov	r7, r6
 410 02ac 080000EA 		b	.L16
 411              	.L57:
 368:../LPCUSB/usbstdreq.c **** 		if (pSetup->wValue == FEA_ENDPOINT_HALT) {
 412              		.loc 1 368 0
 413 02b0 B230D4E1 		ldrh	r3, [r4, #2]
 414 02b4 000053E3 		cmp	r3, #0
 415 02b8 0400001A 		bne	.L48
 370:../LPCUSB/usbstdreq.c **** 			USBHwEPStall(pSetup->wIndex, TRUE);
 416              		.loc 1 370 0
 417 02bc 0400D4E5 		ldrb	r0, [r4, #4]	@ zero_extendqisi2
 418 02c0 0110A0E3 		mov	r1, #1
 419 02c4 FEFFFFEB 		bl	USBHwEPStall
 420              	.LVL38:
 421              	.L53:
 385:../LPCUSB/usbstdreq.c **** 	return TRUE;
 422              		.loc 1 385 0
 423 02c8 0170A0E3 		mov	r7, #1
 424 02cc 000000EA 		b	.L16
 425              	.LVL39:
 426              	.L48:
 374:../LPCUSB/usbstdreq.c **** 		return FALSE;
 427              		.loc 1 374 0
 428 02d0 0070A0E3 		mov	r7, #0
 429              	.LVL40:
 430              	.L16:
 431              	.LBE27:
 432              	.LBE26:
 413:../LPCUSB/usbstdreq.c **** }
 433              		.loc 1 413 0
 434 02d4 0700A0E1 		mov	r0, r7
 435 02d8 F041BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, lr}
 436 02dc 1EFF2FE1 		bx	lr
 437              	.L59:
 438              		.align	2
 439              	.L58:
 440 02e0 00000000 		.word	.LANCHOR0
 441              		.cfi_endproc
 442              	.LFE6:
 444              		.align	2
 445              		.global	USBRegisterCustomReqHandler
 447              	USBRegisterCustomReqHandler:
 448              	.LFB7:
 430:../LPCUSB/usbstdreq.c **** {
 449              		.loc 1 430 0
 450              		.cfi_startproc
 451              		@ Function supports interworking.
 452              		@ args = 0, pretend = 0, frame = 0
 453              		@ frame_needed = 0, uses_anonymous_args = 0
 454              		@ link register save eliminated.
 455              	.LVL41:
 431:../LPCUSB/usbstdreq.c **** 	pfnHandleCustomReq = pfnHandler;
 456              		.loc 1 431 0
 457 02e4 04309FE5 		ldr	r3, .L61
 458 02e8 040083E5 		str	r0, [r3, #4]
 459              		.loc 1 432 0
 460 02ec 1EFF2FE1 		bx	lr
 461              	.L62:
 462              		.align	2
 463              	.L61:
 464 02f0 00000000 		.word	.LANCHOR0
 465              		.cfi_endproc
 466              	.LFE7:
 468              		.bss
 469              		.align	2
 470              		.set	.LANCHOR0,. + 0
 473              	pabDescrip:
 474 0000 00000000 		.space	4
 477              	pfnHandleCustomReq:
 478 0004 00000000 		.space	4
 481              	bConfiguration:
 482 0008 00       		.space	1
 483 0009 000000   		.text
 484              	.Letext0:
 485              		.file 2 "../LPCUSB/type.h"
 486              		.file 3 "../LPCUSB/usbstruct.h"
 487              		.file 4 "../LPCUSB/usbapi.h"
DEFINED SYMBOLS
                            *ABS*:00000000 usbstdreq.c
     /tmp/cczZDsVA.s:16     .text:00000000 $a
     /tmp/cczZDsVA.s:19     .text:00000000 USBRegisterDescriptors
     /tmp/cczZDsVA.s:37     .text:0000000c $d
     /tmp/cczZDsVA.s:41     .text:00000010 $a
     /tmp/cczZDsVA.s:44     .text:00000010 USBGetDescriptor
     /tmp/cczZDsVA.s:124    .text:00000080 $d
     /tmp/cczZDsVA.s:128    .text:00000084 $a
     /tmp/cczZDsVA.s:131    .text:00000084 USBHandleStandardRequest
     /tmp/cczZDsVA.s:188    .text:000000e8 $d
     /tmp/cczZDsVA.s:200    .text:00000110 $a
     /tmp/cczZDsVA.s:440    .text:000002e0 $d
     /tmp/cczZDsVA.s:444    .text:000002e4 $a
     /tmp/cczZDsVA.s:447    .text:000002e4 USBRegisterCustomReqHandler
     /tmp/cczZDsVA.s:464    .text:000002f0 $d
     /tmp/cczZDsVA.s:469    .bss:00000000 $d
     /tmp/cczZDsVA.s:473    .bss:00000000 pabDescrip
     /tmp/cczZDsVA.s:477    .bss:00000004 pfnHandleCustomReq
     /tmp/cczZDsVA.s:481    .bss:00000008 bConfiguration
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
USBHwSetAddress
USBHwEPConfig
USBHwConfigDevice
USBHwEPGetStatus
USBHwEPStall
